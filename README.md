# spamgen

How can we get the word out on healthy, effective herbal remedies without being detected by Big Pharma? SpamGen!

And how can we use a web app to do so? [SpamUX](https://github.com/kennytilton/spamux/blob/master/README.md)!

And how about bar bets about dart scores? `board-yielding-highest-unattainable`!

## Installation

Clone this repository then `lein test`. No actual tests, just runs a batch of whatever size I tested last. Should just end with run statistics and then:
````bash
Ran 1 tests containing 0 assertions.
0 failures, 0 errors.
````

## Usage

A standalone binary that can find its directories can be built thus:
````bash
cd <this repo top dir>
lein bin
cp bin/spamgen .
./spamgen -h
````
(But this repo comes with the above pre-built.)

Now a multi-threaded processing of emails pre-generated by `spec/gen` can be be kicked off with:
````bash
./spamgen -t
````
That works off the default, `em-100000-100.edn`. To run another file in the `bulkinput/` directory (also adding the verbose option to see individual worker stats):
````bash
./spamgen -tem-300000.edn -v
````
If you now examine the directory `bulkmail` you should see a bunch of files name like em1.2.3.4.txt. Each begins with a header object showing the run date and suggested SMPTP server's ID.

The idea is that in parallel we cannot enforce sequential anti-spam constraints, so the plan is to send each output file from a different SMTP server with the IPs shown. Note that concatenating would not work because constraints could be violated at the junctures.

## Options

Try: `./spamgen -h`

## Discussion
It turns out that spec/gen was the source of 70% of the run-time effort, and spitting output emails individually another lesser slow down. Running instead from prebuilt inputs and doing things in batches of a hundred has `spamgen` running five times faster.

Maintaining statistics in an atom does not seem to be a factor, nor does using a shared atom to watch for duplicate email addresses.

## Future work
Next investigation will see if transducers can help, but first we will put a front-end on the beast.

Also, write a similar program to pull in the output files and validate that all constraints have in fact been observed, as our testing during development confirmed.

# Fun with darts
We now have a `dartgen.core` namespace with two functions.

## low-score-unattainable [dart-ct dart-scores]
Given a dartboard with possible scores `dart-scores`, a vector, what is the lowest score unattainable? Darts are allowed to miss and score zero. Note that if the scores do not include one, one is the lowest score unattainable.

## board-yielding-highest-unattainable [options]
Given a number of slices and darts, how can scores be assigned to slices to maximize the low-score-unattainable?

This tool simply tries a range of maxima for the scores to be assigned, then for the number of darts, computes the `low-score-unattainable` of all possible board scorings given the number of slices.

We observe that the highest unattainable increases with max score until an apparent limit is reached for the given number of slices and darts. This is discussed in [the source](https://github.com/kennytilton/spamgen/blob/master/src/dartgen/core.clj).  

## License

Copyright Â© 2018 Kenneth Tilton

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
