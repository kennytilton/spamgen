<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="">
      <change type="DELETED" beforePath="$PROJECT_DIR$/bulkinput/emf-10.edn" afterPath="" />
      <change type="DELETED" beforePath="$PROJECT_DIR$/bulkinput/emf-100.edn" afterPath="" />
      <change type="DELETED" beforePath="$PROJECT_DIR$/bulkinput/emf-1000.edn" afterPath="" />
      <change type="DELETED" beforePath="$PROJECT_DIR$/bulkmail/place.holder" afterPath="" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/.idea/workspace.xml" afterPath="$PROJECT_DIR$/.idea/workspace.xml" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/src/spamgen/core.clj" afterPath="$PROJECT_DIR$/src/spamgen/core.clj" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/src/spamgen/genlist.clj" afterPath="$PROJECT_DIR$/src/spamgen/genlist.clj" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/test/spamgen/core_test.clj" afterPath="$PROJECT_DIR$/test/spamgen/core_test.clj" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="project.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="357">
              <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core_test.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="230">
              <caret line="14" column="0" lean-forward="false" selection-start-line="14" selection-start-column="0" selection-end-line="14" selection-end-column="0" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.clj" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="377">
              <caret line="221" column="39" lean-forward="true" selection-start-line="221" selection-start-column="39" selection-end-line="221" selection-end-column="39" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>test-email-records</find>
      <find>println</find>
      <find>:sent</find>
      <find>env</find>
      <find>running-mean-ok?</find>
      <find>running-mean</find>
      <find>:rejected-span-mean</find>
      <find>:rejected-last-n</find>
      <find>:last-n-mean</find>
      <find>span-mean</find>
      <find>:max-overall-spam-score</find>
      <find>:overall-mean-max</find>
      <find>:individual-max</find>
      <find>:score-sum</find>
      <find>:total-email-ct</find>
      <find>:rejected-</find>
      <find>:max-individual-spam-score</find>
      <find>RV</find>
      <find>rejected-abs</find>
      <find>em-ct</find>
      <find>slices</find>
    </findStrings>
    <replaceStrings>
      <replace>em-addrs-hit</replace>
      <replace>:addrs-hit</replace>
      <replace>*env*</replace>
      <replace>span-mean-ok</replace>
      <replace>:rejected-span-mean</replace>
      <replace>last-n-mean</replace>
      <replace>last-n-span</replace>
      <replace>env-hack</replace>
      <replace>:span-mean</replace>
      <replace>last-n</replace>
      <replace>:overall-mean-max</replace>
      <replace>:spam-score-sum</replace>
      <replace>:individual-max</replace>
      <replace>XXX</replace>
      <replace>RV</replace>
      <replace>:rejected-overall-mean</replace>
      <replace>XX</replace>
      <replace>rejected-score</replace>
      <replace>sent-ct</replace>
      <replace>scores</replace>
      <replace>board</replace>
    </replaceStrings>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/resources/config.edn" />
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/config/dev/config.edn" />
        <option value="$PROJECT_DIR$/src/spamgen/genlist.clj" />
        <option value="$PROJECT_DIR$/test/spamgen/core_test.clj" />
        <option value="$PROJECT_DIR$/src/spamgen/core.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds">
    <option name="x" value="93" />
    <option name="y" value="68" />
    <option name="width" value="1425" />
    <option name="height" value="886" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="AndroidView" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
              <item name="dev" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="Scope" />
      <pane id="PackagesPane" />
      <pane id="Scratches" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="configurable.group.build" />
    <property name="cursive.last.file.extension./Users/kennethtilton/spamgen/src" value="clj" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/config/dev" />
    </key>
  </component>
  <component name="ReplState" timestamp="1521916123421">{:repl-history {:ide [], :local [{:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 400000))))\n  (pln :devtest-fini))&quot;, :offset 169, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-records-duped-test-gen\n  ([] (repeatedly\n        #(gen/generate (s/gen ::email-record-duped))))\n  ([n]\n   (if (nil? n)\n     (email-records-duped-test-gen)\n     (take n (email-records-duped-test-gen)))))&quot;, :offset 214, :ns &quot;spamgen.genlist&quot;} {:command &quot;(email-records-duped-test-gen 1)&quot;, :offset 32, :ns &quot;spamgen.genlist&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (println :multiprocessing)\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct              0\n                                          :last-n-mean        0\n                                          :spam-score-sum     0\n                                          :rejected-abs       0\n                                          :rejected-dup-addr  0\n                                          :rejected-overall-mean   0\n                                          :rejected-span-mean 0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (doseq [w workers]\n      (pln)\n      (pln (format \&quot;worker %d:\&quot; (:id w)))\n      (pp/pprint @(:stats w))\n      (pln))\n\n    (pln :summary)\n    (pln (apply merge-with +\n           (map #(select-keys @(:stats %) [:em-ct]) workers)))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2629, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (println :multiprocessing)\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct              0\n                                          :last-n-mean        0\n                                          :spam-score-sum     0\n                                          :rejected-abs       0\n                                          :rejected-dup-addr  0\n                                          :rejected-overall-mean   0\n                                          :rejected-span-mean 0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (doseq [w workers]\n      (pln)\n      (pln (format \&quot;worker %d:\&quot; (:id w)))\n      (pp/pprint @(:stats w))\n      (pln))\n\n    (pln :summary)\n    (pln (apply merge-with +\n           (map #(select-keys @(:stats %)\n                   [:em-ct :rejected-abs :rejected-dup-addr\n                    :rejected-overall-mean\n                    :rejected-span-mean])\n             workers)))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2777, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (println :multiprocessing)\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct              0\n                                          :last-n-mean        0\n                                          :spam-score-sum     0\n                                          :rejected-abs       0\n                                          :rejected-dup-addr  0\n                                          :rejected-overall-mean   0\n                                          :rejected-span-mean 0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (doseq [w workers]\n      (pln)\n      (pln (format \&quot;worker %d:\&quot; (:id w)))\n      (pp/pprint @(:stats w))\n      (pln))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n           (map #(select-keys @(:stats %)\n                   [:em-ct :rejected-abs :rejected-dup-addr\n                    :rejected-overall-mean\n                    :rejected-span-mean])\n             workers)))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2783, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (println :multiprocessing)\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct              0\n                                          :last-n-mean        0\n                                          :spam-score-sum     0\n                                          :rejected-abs       0\n                                          :rejected-dup-addr  0\n                                          :rejected-overall-mean   0\n                                          :rejected-span-mean 0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (doseq [w workers]\n      (pln)\n      (pln (format \&quot;worker %d:\&quot; (:id w)))\n      (pp/pprint @(:stats w))\n      (pln))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n           (map #(select-keys @(:stats %)\n                   [:em-ct :rejected-abs :rejected-dup-addr\n                    :rejected-overall-mean\n                    :rejected-span-mean])\n             workers)))\n    \n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2797, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-abs] inc)\n      #_ (pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        ;; do not apply test until sample size useful,\n        ;; arbitrarily adopting :last-n parameter as useful\n        (and (&gt; new-ct (:last-n-span env-hack))\n          (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack)))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            #_ (pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            #_ (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:em-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_ (pln :sending-to (:id w) (:spam-score task)\n            :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2408, :ns &quot;spamgen.core&quot;} {:command &quot;(def spamgen-cli\n  [[\&quot;-t\&quot; \&quot;--test TESTCOUNT\&quot; \&quot;Number of test email records to process ignoring file arg\&quot;\n    :id :test-count\n    :default 100\n    ;; todo handle inputs like 100k\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1)\&quot;]]\n   [\&quot;-v\&quot; \&quot;--verbose\&quot;]\n  \n   [\&quot;-h\&quot; \&quot;--help\&quot;]])&quot;, :offset 326, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 30000)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 182, :ns &quot;spamgen.core-test&quot;} {:command &quot;(s/def ::spam-score\n  (s/double-in :min 0.0 :max 1))&quot;, :offset 52, :ns &quot;spamgen.genlist&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        ;; do not apply test until sample size useful,\n        ;; arbitrarily adopting :last-n parameter as useful\n        (and (&gt; new-ct (:last-n-span env-hack))\n          (&gt; (/ new-sum new-ct)\n            (:overall-mean-max env-hack)))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            #_(pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            #_(pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2414, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 50000)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 182, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 10000)\n        true)))\n  (pln :devtest-fini))&quot;, :offset 181, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  ;;(pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        ;; do not apply test until sample size useful,\n        ;; arbitrarily adopting :last-n parameter as useful\n        (and ;; (&gt; new-ct (:last-n-span env-hack))\n          (&gt; (/ new-sum new-ct)\n            (:overall-mean-max env-hack)))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            #_(pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            #_(pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2419, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  ;;(pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        ;; do not apply test until sample size useful,\n        ;; arbitrarily adopting :last-n parameter as useful\n        (and (&gt; new-ct (:last-n-span env-hack))\n          (&gt; (/ new-sum new-ct)\n            (:overall-mean-max env-hack)))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            #_(pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            #_(pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2416, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  ;;(pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        ;; do not apply test until sample size useful,\n        ;; arbitrarily adopting :last-n parameter as useful\n        (and ;;(&gt; new-ct (:last-n-span env-hack))\n          (&gt; (/ new-sum new-ct)\n            (:overall-mean-max env-hack)))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            #_(pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            #_(pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2418, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  ;;(pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            #_(pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            #_(pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2248, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2889, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2890, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (doseq [em-rec email-stream]\n        ((&gt;!! shared-chan em-rec))))\n    \n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2995, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (doseq [em-rec email-stream]\n        (&gt;!! shared-chan em-rec)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2989, :ns &quot;spamgen.core&quot;} {:command &quot;(println (partition 4 (range 20)))&quot;, :offset 34, :ns &quot;spamgen.core-test&quot;} {:command &quot;(type (partition 4 (range 20)))&quot;, :offset 31, :ns &quot;spamgen.core-test&quot;} {:command &quot;(type (first (partition 4 (range 20))))&quot;, :offset 39, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker stream]\n               (go\n                 (doseq [e stream]\n                   (&gt;! (:ch worker)))))\n          workers\n          (partition (count workers) email-stream))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3131, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [feeders (map (fn [worker stream] \n                           (go \n                             (doseq [e stream] \n                               (&gt;! (:ch worker))))) \n                      workers \n                      (partition (count workers) email-stream))]\n        (loop [[f &amp; rf :as ps] feeders]\n          (when f\n            (when-let [out (alt!!\n                             (timeout 100) :timeout\n                             f ([r] r))]\n              (recur rf))))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3411, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [feeders (map (fn [worker stream]\n                           (go\n                             (doseq [e stream]\n                               (&gt;! (:ch worker) e))))\n                      workers\n                      (partition (count workers) email-stream))]\n        (loop [[f &amp; rf :as ps] feeders]\n          (when f\n            (when-let [out (alt!!\n                             (timeout 100) :timeout\n                             f ([r] r))]\n              (recur rf))))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3408, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 1000)\n        true)))\n  (pln :devtest-fini))&quot;, :offset 180, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 1000)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 181, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [feeders (map (fn [worker stream]\n                           (go\n                             (doseq [e stream]\n                               (&gt;! (:ch worker) e))))\n                      workers\n                      (partition (count workers) email-stream))]\n        (pln :waiting-on-feeders)\n        (loop [[f &amp; rf :as ps] feeders]\n          (when f\n            (when-let [out (alt!!\n                             (timeout 100) :timeout\n                             f ([r] r))]\n              (recur rf))))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3442, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [feeders (map (fn [worker stream]\n                           (go\n                             (doseq [e stream]\n                               (&gt;! (:ch worker) e))))\n                      workers\n                      (partition (count workers) email-stream))]\n        (pln :waiting-on-feeders)\n        (loop [[f &amp; rf :as ps] feeders]\n          (when f\n            (when-let [out (alt!!\n                             (timeout 100) :timeout\n                             f ([r] r))]\n              (pln :feeder-done f)\n              (recur rf))))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3477, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [feeders (map (fn [worker stream]\n                           (go\n                             (doseq [e stream]\n                               (&gt;! (:ch worker) e))))\n                      workers\n                      (partition (count workers) email-stream))]\n        (pln :waiting-on-feeders (count feeders))\n        (loop [[f &amp; rf :as ps] feeders]\n          (when f\n            (when-let [out (alt!!\n                             (timeout 100) :timeout\n                             f ([r] r))]\n              (pln :feeder-done f)\n              (recur rf))))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3493, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [feeders (map (fn [worker stream]\n                           (go\n                             (doseq [e stream]\n                               (&gt;! (:ch worker) e))))\n                      workers\n                      (partition (count workers) email-stream))]\n        (pln :waiting-on-feeders (count feeders))\n        (loop [[f &amp; rf :as fs] feeders]\n          (pln :floop f (count rf))\n          (when f\n            (when-let [out (alt!!\n                             (timeout 100) :timeout\n                             f ([r] r))]\n              (pln :feeder-done f)\n              (recur rf))))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3529, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [feeders (map (fn [worker stream]\n                           (go\n                             (doseq [e stream]\n                               (&gt;! (:ch worker) e))))\n                      workers\n                      (partition (count workers) email-stream))]\n        (pln :waiting-on-feeders (count feeders))\n        (loop [[f &amp; rf :as fs] feeders]\n          (pln :floop f (count rf))\n          (when f\n            (when-let [out (alt!!\n                             (timeout 1000) :timeout\n                             f :f-done)]\n              (pln :feeder-done f out)\n              (recur rf))))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3534, :ns &quot;spamgen.core&quot;} {:command &quot;(partition 3 (range 18))&quot;, :offset 24, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [worker-chans (map :ch workers)]\n        (dorun\n          (map (fn [emails]\n               (pmap (fn [w e]\n                       (&gt;! (:ch worker) e))\n                 worker-chans emails))\n          (partition (count workers) email-stream)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3177, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [worker-chans (map :ch workers)]\n        (dorun\n          (map (fn [emails]\n               (pmap (fn [wch e]\n                       (&gt;! wch e))\n                 worker-chans emails))\n          (partition (count workers) email-stream)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3170, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [worker-chans (map :ch workers)]\n        (dorun\n          (map (fn [emails]\n                 (pln :ems)\n               (pmap (fn [wch e]\n                       (&gt;! wch e))\n                 worker-chans emails))\n          (partition (count workers) email-stream)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3198, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [worker-chans (map :ch workers)]\n        (dorun\n          (map (fn [emails]\n                 (pln :ems emails)\n               (pmap (fn [wch e]\n                       (&gt;! wch e))\n                 worker-chans emails))\n          (partition (count workers) email-stream)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3205, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [worker-chans (map :ch workers)]\n        (dorun\n          (map (fn [emails]\n                 (pln :ems emails)\n               (map (fn [wch e]\n                       (&gt;! wch e))\n                 worker-chans emails))\n          (partition (count workers) email-stream)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3204, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [worker-chans (map :ch workers)]\n        (pln :chans worker-chans)\n        (dorun\n          (map (fn [emails]\n                 (pln :ems emails) \n                 (map (fn [wch e] \n                        (&gt;!! wch e))\n                 worker-chans emails))\n          (partition (count workers) email-stream)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3244, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [worker-chans (map :ch workers)]\n        (pln :chans worker-chans)\n        (dorun\n          (map (fn [emails]\n                 (pln :ems emails)\n                 (map (fn [wch e]\n                        (pln e)\n                        (&gt;!! wch e))\n                  worker-chans emails))\n          (partition (count workers) email-stream)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3275, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [worker-chans (map :ch workers)]\n        (pln :chans worker-chans)\n        (dorun\n          (map (fn [emails]\n                 (pln :ems emails)\n                 (map (fn [wch e]\n                        (pln :bam e)\n                        (&gt;!! wch e))\n                  worker-chans emails))\n          (partition (count workers) email-stream)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3280, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [worker-chans (map :ch workers)]\n        (pln :chans worker-chans)\n        (dorun\n          (map (fn [emails]\n                 (pln :ems emails (count worker-chans))\n                 (map (fn [wch e]\n                        (pln :bam e)\n                        (&gt;!! wch e))\n                  worker-chans emails))\n          (partition (count workers) email-stream)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3301, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 100)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 180, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        ;; shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 100)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct                 0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    #_\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (p :feed-workers\n      (let [worker-chans (map :ch workers)]\n        (pln :chans worker-chans)\n        (dorun\n          (map (fn [emails]\n                 ;(pln :ems emails (count worker-chans))\n                 (dorun\n                   (map (fn [wch e]\n                        \n                        (&gt;!! wch e))\n                  worker-chans emails)))\n          (partition (count workers) email-stream)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3317, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 10000)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 182, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart [dart-ct slices]\n  (let [nslices (sort (distinct slices))\n        gapless (atom 0)]\n    (letfn [(throw [dart-no score-so-far]\n              ;; todo start with first slice that can take us to a higher score, unless\n              ;; it turns out that is no more efficient or less scrutable. It could be no more\n              ;; efficient because identifying the first plausible candidate requires the same\n              ;; comparisions.\n              (loop [[throw-score &amp; rthrows] nslices\n                     next-in-order (inc @gapless)]\n                (when throw-score\n                  (let [new-total (+ score-so-far throw-score)]\n                    (cond\n                      (&gt; new-total next-in-order)\n                      ;; Punt. rthrows contains only higher values because they are sorted, so\n                      ;; we cannot hit next-in-order by continuing.\n                      (do)\n\n                      (= new-total next-in-order)\n                      (do\n                        (swap! gapless inc)\n                        ;; we keep going as an efficiency: if the next slice is one more\n                        ;; than the current slice, we can bump our gapless value straight away,\n                        ;; effectively pruning further searching.\n                        (recur rthrows new-total))\n\n                      :default\n                      ;; the tree search will revisit nodes with lower totals, so just keep\n                      ;; gowing to pick up higher nodes.\n                      (do\n                        (when (&gt; dart-no 1)\n                          (throw (dec dart-no) new-total)\n                          (recur rthrows))))))))]\n      (throw dart-ct 0)\n      (inc @gapless))))&quot;, :offset 1750, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart [dart-ct slices]\n  (let [nslices (sort (distinct slices))\n        gapless (atom 0)]\n    (letfn [(throw-dart [dart-no score-so-far]\n              (loop [next-in-order (inc @gapless)\n                     [throw-score &amp; rthrows] nslices\n                     ]\n                (when throw-score\n                  (let [new-total (+ score-so-far throw-score)]\n                    (cond\n                      (&gt; new-total next-in-order)\n                      ;; Punt. rthrows contains only higher values because they are sorted, so\n                      ;; we cannot hit next-in-order by continuing.\n                      (do)\n\n                      (= new-total next-in-order)\n                      (do\n                        (swap! gapless inc)\n                        ;; we keep going as an efficiency: if the next slice is one more\n                        ;; than the current slice, we can bump our gapless value straight away,\n                        ;; effectively pruning further searching.\n                        (recur rthrows (inc new-total)))\n\n                      :default\n                      ;; the tree search will revisit nodes with lower totals, so just keep\n                      ;; gowing to pick up higher nodes.\n                      (do\n                        (when (&gt; dart-no 1)\n                          (throw-dart (dec dart-no) new-total))\n                        (recur rthrows)))))))]\n      (throw-dart dart-ct 0)\n      (inc @gapless))))&quot;, :offset 1482, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart [dart-ct slices]\n  (let [nslices (sort (distinct slices))\n        gapless (atom 0)]\n    (letfn [(throw-dart [dart-no score-so-far]\n              (loop [next-in-order (inc @gapless)\n                     [throw-score &amp; rthrows] nslices\n                     ]\n                (when throw-score\n                  (let [new-total (+ score-so-far throw-score)]\n                    (cond\n                      (= new-total next-in-order)\n                      (do\n                        (swap! gapless inc)\n                        ;; we keep going as an efficiency: if the next slice is one more\n                        ;; than the current slice, we can bump our gapless value straight away,\n                        ;; effectively pruning further searching.\n                        (recur rthrows (inc new-total)))\n                      \n                      (&gt; new-total next-in-order)\n                      ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                      ;; and try the next, if any, which will possibly have access to lower values.\n                      (when (&gt; dart-no 1)\n                        (throw-dart (dec dart-no) new-total))\n                      \n                      :default ;; ie, new-total too low\n                      ;; try next dart if any and keep trying this dart\n                      (do\n                        (when (&gt; dart-no 1)\n                          (throw-dart (dec dart-no) new-total))\n                        (recur next-in-order rthrows)))))))]\n      (throw-dart dart-ct 0)\n      (inc @gapless))))&quot;, :offset 1600, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest darts\n  (let [slices [2 3 4]]\n    (is (= 1 (no-can-dart 1 slices)))))&quot;, :offset 78, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest darts\n  (let [slices [2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 1 (no-can-dart 1 slices)))\n    (is (= 1 (no-can-dart 10 slices))))\n  (let [slices [1 2 3 4]]\n    (is = 1 (no-can-dart 0 slices))))&quot;, :offset 218, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest darts\n  (let [slices [2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 1 (no-can-dart 1 slices)))\n    (is (= 1 (no-can-dart 10 slices))))\n  (let [slices [1 2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))))&quot;, :offset 220, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart [dart-ct slices]\n  (let [nslices (sort (distinct slices))\n        gapless (atom 0)]\n    (letfn [(throw-dart [dart-no score-so-far]\n              (loop [next-in-order (inc @gapless)\n                     [throw-score &amp; rthrows] nslices\n                     ]\n                (when throw-score\n                  (let [new-total (+ score-so-far throw-score)]\n                    (cond\n                      (= new-total next-in-order)\n                      (do\n                        (swap! gapless inc)\n                        ;; we keep going as an efficiency: if the next slice is one more\n                        ;; than the current slice, we can bump our gapless value straight away,\n                        ;; effectively pruning further searching.\n                        (recur (inc new-total) rthrows ))\n\n                      (&gt; new-total next-in-order)\n                      ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                      ;; and try the next, if any, which will possibly have access to lower values.\n                      (when (&gt; dart-no 1)\n                        (throw-dart (dec dart-no) new-total))\n\n                      :default ;; ie, new-total too low\n                      ;; try next dart if any and keep trying this dart\n                      (do\n                        (when (&gt; dart-no 1)\n                          (throw-dart (dec dart-no) new-total))\n                        (recur next-in-order rthrows)))))))]\n      (throw-dart dart-ct 0)\n      (inc @gapless))))&quot;, :offset 1557, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart [dart-ct slices]\n  (let [nslices (sort (distinct slices))\n        gapless (atom 0)]\n    (letfn [(throw-dart [dart-no score-so-far]\n              (when (pos? dart-no)\n                (loop [next-in-order (inc @gapless)\n                       [throw-score &amp; rthrows] nslices\n                       ]\n                  (when throw-score\n                    (let [new-total (+ score-so-far throw-score)]\n                      (cond\n                        (= new-total next-in-order)\n                        (do\n                          (swap! gapless inc)\n                          ;; we keep going as an efficiency: if the next slice is one more\n                          ;; than the current slice, we can bump our gapless value straight away,\n                          ;; effectively pruning further searching.\n                          (recur (inc new-total) rthrows))\n\n                        (&gt; new-total next-in-order)\n                        ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                        ;; and try the next, if any, which will possibly have access to lower values.\n                        (throw-dart (dec dart-no) new-total)\n\n                        :default                            ;; ie, new-total too low\n                        ;; try next dart if any and keep trying this dart\n                        (do\n                          (throw-dart (dec dart-no) new-total)\n                          (recur next-in-order rthrows))))))))]\n      (throw-dart dart-ct 0)\n      (inc @gapless))))&quot;, :offset 1571, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest darts\n  (let [slices [2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 1 (no-can-dart 1 slices)))\n    (is (= 1 (no-can-dart 10 slices))))\n  (let [slices [1 2 3 4]]\n    (doseq [dart-ct (range 4)]\n      (is (= (no-can-dart dart-ct slices)\n            (inc (* dart-ct (last slices))))))))&quot;, :offset 302, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest darts\n  (let [slices [2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 1 (no-can-dart 1 slices)))\n    (is (= 1 (no-can-dart 10 slices))))\n  (let [slices [1 2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 5 (no-can-dart 1 slices)))\n    (println :two (no-can-dart 2 slices))\n    (is (= 9 (no-can-dart 2 slices)))))&quot;, :offset 338, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart [dart-ct slices]\n  (let [nslices (sort (distinct slices))\n        gapless (atom 0)]\n    (letfn [(throw-dart [dart-no score-so-far]\n              (when (pos? dart-no)\n                (loop [next-in-order (inc @gapless)\n                       [throw-score &amp; rthrows] nslices\n                       ]\n                  (when throw-score\n                    (let [new-total (+ score-so-far throw-score)]\n                      (cond\n                        (= new-total next-in-order)\n                        (do\n                          (swap! gapless inc)\n                          ;; we keep going as an efficiency: if the next slice is one more\n                          ;; than the current slice, we can bump our gapless value straight away,\n                          ;; effectively pruning further searching.\n                          (throw-dart (dec dart-no) new-total)\n                          (recur (inc new-total) rthrows))\n\n                        (&gt; new-total next-in-order)\n                        ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                        ;; and try the next, if any, which will possibly have access to lower values.\n                        (throw-dart (dec dart-no) new-total)\n\n                        :default                            ;; ie, new-total too low\n                        ;; try next dart if any and keep trying this dart\n                        (do\n                          (throw-dart (dec dart-no) new-total)\n                          (recur next-in-order rthrows))))))))]\n      (throw-dart dart-ct 0)\n      (inc @gapless))))&quot;, :offset 1634, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart [dart-ct slices]\n  (let [nslices (sort (distinct slices))\n        gapless (atom 0)]\n    (letfn [(throw-dart [dart-no score-so-far]\n              (when (pos? dart-no)\n                (loop [next-in-order (inc @gapless)\n                       [throw-score &amp; rthrows] nslices\n                       ]\n                  (when throw-score\n                    (let [new-total (+ score-so-far throw-score)]\n                      (cond\n                        (= new-total (inc @gapless))\n                        (do\n                          (swap! gapless inc)\n                          ;; we keep going as an efficiency: if the next slice is one more\n                          ;; than the current slice, we can bump our gapless value straight away,\n                          ;; effectively pruning further searching.\n                          (throw-dart (dec dart-no) new-total)\n                          (recur (inc new-total) rthrows))\n\n                        (&gt; new-total (inc @gapless))\n                        ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                        ;; and try the next, if any, which will possibly have access to lower values.\n                        (throw-dart (dec dart-no) new-total)\n\n                        :default                            ;; ie, new-total too low\n                        ;; try next dart if any and keep trying this dart\n                        (do\n                          (throw-dart (dec dart-no) new-total)\n                          (recur (inc @gapless) rthrows))))))))]\n      (throw-dart dart-ct 0)\n      (inc @gapless))))&quot;, :offset 1637, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart [dart-ct slices]\n  (let [nslices (sort (distinct slices))\n        gapless (atom 0)]\n    (letfn [(next-in-order []\n              (inc @gapless))\n            (throw-dart [dart-no score-so-far]\n              (when (pos? dart-no)\n                (loop [[throw-score &amp; rthrows] nslices]\n                  (when throw-score\n                    (let [new-total (+ score-so-far throw-score)]\n                      (cond\n                        (= new-total (next-in-order))\n                        (do\n                          (swap! gapless inc)\n                          ;; we keep going as an efficiency: if the next slice is one more\n                          ;; than the current slice, we can bump our gapless value straight away,\n                          ;; effectively pruning further searching.\n                          (throw-dart (dec dart-no) new-total)\n                          (recur (inc new-total) rthrows))\n\n                        (&gt; new-total (next-in-order))\n                        ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                        ;; and try the next, if any, which will possibly have access to lower values.\n                        (throw-dart (dec dart-no) new-total)\n\n                        :default                            ;; ie, new-total too low\n                        ;; try next dart if any and keep trying this dart\n                        (do\n                          (throw-dart (dec dart-no) new-total)\n                          (recur (next-in-order) rthrows))))))))]\n      (throw-dart dart-ct 0)\n      (next-in-order))))&quot;, :offset 1625, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart [dart-ct slices]\n  (let [nslices (sort (distinct slices))\n        gapless (atom 0)]\n    (letfn [(next-in-order []\n              (inc @gapless))\n            (throw-dart [dart-no score-so-far]\n              (when (pos? dart-no)\n                (loop [[throw-score &amp; rthrows] nslices]\n                  (when throw-score\n                    (let [new-total (+ score-so-far throw-score)]\n                      (cond\n                        (= new-total (next-in-order))\n                        (do\n                          (swap! gapless inc)\n                          ;; we keep going as an efficiency: if the next slice is one more\n                          ;; than the current slice, we can bump our gapless value straight away,\n                          ;; effectively pruning further searching.\n                          (throw-dart (dec dart-no) new-total)\n                          (recur rthrows))\n\n                        (&gt; new-total (next-in-order))\n                        ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                        ;; and try the next, if any, which will possibly have access to lower values.\n                        (throw-dart (dec dart-no) new-total)\n\n                        :default                            ;; ie, new-total too low\n                        ;; try next dart if any and keep trying this dart\n                        (do\n                          (throw-dart (dec dart-no) new-total)\n                          (recur rthrows))))))))]\n      (throw-dart dart-ct 0)\n      (next-in-order))))&quot;, :offset 1593, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest darts\n  (let [slices [2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 1 (no-can-dart 1 slices)))\n    (is (= 1 (no-can-dart 10 slices))))\n  (let [slices [1 2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 5 (no-can-dart 1 slices)))\n    (is (= 9 (no-can-dart 2 slices))))\n  (let [slices [1 3]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 2 (no-can-dart 1 slices)))\n    (is (= 5 (no-can-dart 2 slices))))\n  (let [slices [1 3 7]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 2 (no-can-dart 1 slices)))\n    (is (= 5 (no-can-dart 2 slices)))\n    (is (= 12 (no-can-dart 3 slices)))))&quot;, :offset 611, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest darts\n  (let [slices [2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 1 (no-can-dart 1 slices)))\n    (is (= 1 (no-can-dart 10 slices))))\n  (let [slices [1 2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 5 (no-can-dart 1 slices)))\n    (is (= 9 (no-can-dart 2 slices))))\n  (let [slices [1 3]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 2 (no-can-dart 1 slices)))\n    (is (= 5 (no-can-dart 2 slices)))\n    (is (= 5 (no-can-dart 3 slices))))\n  (let [slices [1 3 7]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 2 (no-can-dart 1 slices)))\n    (is (= 5 (no-can-dart 2 slices)))\n    (is (= 12 (no-can-dart 3 slices)))))&quot;, :offset 649, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart [dart-ct dartboard-scores]\n  (let [scores (sort (distinct dartboard-scores)) ;; short for normalized scores\n        gapless (atom 0)] ;; short for gapless max score observed as we traverse possible scoring combos\n    (letfn [(next-in-order []\n              (inc @gapless))\n            (throw-dart [dart-no score-so-far]\n              (when (pos? dart-no)\n                (loop [[throw-score &amp; rthrows] scores]\n                  (when throw-score\n                    (let [new-total (+ score-so-far throw-score)]\n                      (cond\n                        (= new-total (next-in-order))\n                        (do\n                          (swap! gapless inc)\n                          ;; we keep going as an efficiency: if the next slice is one more\n                          ;; than the current slice, we can bump our gapless value straight away,\n                          ;; effectively pruning further searching.\n                          (throw-dart (dec dart-no) new-total)\n                          (recur rthrows))\n\n                        (&gt; new-total (next-in-order))\n                        ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                        ;; and try the next, if any, which will possibly have access to lower values.\n                        (throw-dart (dec dart-no) new-total)\n\n                        :default                            ;; ie, new-total too low\n                        ;; try next dart if any and keep trying this dart\n                        (do\n                          (throw-dart (dec dart-no) new-total)\n                          (recur rthrows))))))))]\n      (throw-dart dart-ct 0)\n      (next-in-order))))&quot;, :offset 1721, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest darts\n  (let [slices [2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 1 (no-can-dart 1 slices)))\n    (is (= 1 (no-can-dart 10 slices))))\n  (let [slices [1 2 3 4]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 5 (no-can-dart 1 slices)))\n    (is (= 9 (no-can-dart 2 slices))))\n  (let [slices [1 3]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 2 (no-can-dart 1 slices)))\n    (is (= 5 (no-can-dart 2 slices)))\n    (is (= 5 (no-can-dart 3 slices))))\n  (let [slices [1 3 7]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 2 (no-can-dart 1 slices)))\n    (is (= 5 (no-can-dart 2 slices)))\n    (is (= 12 (no-can-dart 3 slices))))\n  (let [slices [1 4 7]]\n    (is (= 1 (no-can-dart 0 slices)))\n    (is (= 2 (no-can-dart 1 slices)))\n    (is (= 3 (no-can-dart 2 slices)))\n    (is (= 10 (no-can-dart 3 slices)))))&quot;, :offset 827, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart\n  \&quot;Given a nmber of darts and the scores available on a dartboard, return\n  the lowest total score that cannot be scored. e.g., with one dart and \n  scores 1 and 3, we cannot score two. Withe two darts we cannot score 5.\&quot;\n  [dart-ct dartboard-scores]\n\n  (let [scores (sort (distinct dartboard-scores)) ;; short for normalized scores\n        gapless (atom 0)] ;; short for gapless max score observed as we traverse possible scoring combos\n    (letfn [(next-in-order []\n              (inc @gapless))\n            (throw-dart [dart-no score-so-far]\n              (when (pos? dart-no)\n                (loop [[throw-score &amp; rthrows] scores]\n                  (when throw-score\n                    (let [new-total (+ score-so-far throw-score)]\n                      (throw-dart (dec dart-no) new-total)\n                      (cond\n                        (= new-total (next-in-order))\n                        (do\n                          (swap! gapless inc)\n                          ;; we keep going as an efficiency: if the next slice is one more\n                          ;; than the current slice, we can bump our gapless value straight away,\n                          ;; effectively pruning further searching.\n                          (recur rthrows))\n\n                        (&gt; new-total (next-in-order))\n                        ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                        ;; and try the next, if any, which will possibly have access to lower values.\n                        (do)\n\n                        :default                            ;; ie, new-total too low\n                        ;; try next dart if any and keep trying this dart\n                        (recur rthrows)))))))]\n      (throw-dart dart-ct 0)\n      (next-in-order))))&quot;, :offset 1816, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [v [1 2 3 4 5]]\n  (range (count v)))&quot;, :offset 41, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [v [1 2 3 4 5]]\n  (range 1 (inc (count v))))&quot;, :offset 49, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [v [1 2 3 4 5]]\n  (= v (range 1 (inc (count v)))))&quot;, :offset 55, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [v [1 2 3 4 5 7]]\n  (= v (range 1 (inc (count v)))))&quot;, :offset 57, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart\n  \&quot;Given a nmber of darts and the scores available on a dartboard, return\n  the lowest total score that cannot be scored. e.g., with one dart and\n  scores 1 and 3, we cannot score two. Withe two darts we cannot score 5.\&quot;\n  [dart-ct dartboard-scores]\n\n  (let [scores (sort (distinct dartboard-scores))           ;; short for normalized scores\n        gapless (atom 0)]                                   ;; short for gapless max score observed as we traverse possible scoring combos\n    (cond\n      (&gt; (first scores) 1)\n      1\n\n      (= v (range 1 (inc (count v))))\n      (inc (* dart-ct (last scores)))\n\n      :default\n      (letfn [(next-in-order []\n                (inc @gapless))\n              (throw-dart [dart-no score-so-far]\n                (when (pos? dart-no)\n                  (loop [[throw-score &amp; rthrows] scores]\n                    (when throw-score\n                      (let [new-total (+ score-so-far throw-score)]\n                        ;; we could pull the recursive call here since all branches of the cond\n                        ;; invoke it, but methinks that borders on obfuscation\n                        (cond\n                          (= new-total (next-in-order))\n                          (do\n                            (swap! gapless inc)\n                            ;; we keep going as an efficiency: if the next slice is one more\n                            ;; than the current slice, we can bump our gapless value straight away,\n                            ;; effectively pruning further searching.\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))\n\n                          (&gt; new-total (next-in-order))\n                          ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                          ;; and try the next, if any, which will possibly have access to lower values.\n                          (throw-dart (dec dart-no) new-total)\n\n                          :default                          ;; ie, new-total too low\n                          ;; try next dart if any and keep trying this dart\n                          (do\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))))))))]\n        (throw-dart dart-ct 0)\n        (next-in-order)))))&quot;, :offset 2355, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart\n  \&quot;Given a nmber of darts and the scores available on a dartboard, return\n  the lowest total score that cannot be scored. e.g., with one dart and\n  scores 1 and 3, we cannot score two. Withe two darts we cannot score 5.\&quot;\n  [dart-ct dartboard-scores]\n\n  (let [scores (sort (distinct dartboard-scores))           ;; short for normalized scores\n        gapless (atom 0)]                                   ;; short for gapless max score observed as we traverse possible scoring combos\n    (cond\n      (&gt; (first scores) 1)\n      1\n\n      (= dartboard-scores (range 1 (inc (count dartboard-scores))))\n      (inc (* dart-ct (last scores)))\n\n      :default\n      (letfn [(next-in-order []\n                (inc @gapless))\n              (throw-dart [dart-no score-so-far]\n                (when (pos? dart-no)\n                  (loop [[throw-score &amp; rthrows] scores]\n                    (when throw-score\n                      (let [new-total (+ score-so-far throw-score)]\n                        ;; we could pull the recursive call here since all branches of the cond\n                        ;; invoke it, but methinks that borders on obfuscation\n                        (cond\n                          (= new-total (next-in-order))\n                          (do\n                            (swap! gapless inc)\n                            ;; we keep going as an efficiency: if the next slice is one more\n                            ;; than the current slice, we can bump our gapless value straight away,\n                            ;; effectively pruning further searching.\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))\n\n                          (&gt; new-total (next-in-order))\n                          ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                          ;; and try the next, if any, which will possibly have access to lower values.\n                          (throw-dart (dec dart-no) new-total)\n\n                          :default                          ;; ie, new-total too low\n                          ;; try next dart if any and keep trying this dart\n                          (do\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))))))))]\n        (throw-dart dart-ct 0)\n        (next-in-order)))))&quot;, :offset 2385, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart\n  \&quot;Given a nmber of darts and the scores available on a dartboard, return\n  the lowest total score that cannot be scored. e.g., with one dart and\n  scores 1 and 3, we cannot score two. Withe two darts we cannot score 5.\&quot;\n  [dart-ct dartboard-scores]\n\n  (let [scores (sort (distinct dartboard-scores))           ;; short for normalized scores\n        gapless (atom 0)]                                   ;; short for gapless max score observed as we traverse possible scoring combos\n    (cond\n      ;;; nail a couple of special cases\n      (or\n          (not (pos? dart-ct))\n          (empty? dartboard-scores)\n          (&gt; (first scores) 1))\n      1\n\n      ;; this one actually spares us a full sweep\n      (= dartboard-scores (range 1 (inc (count dartboard-scores))))\n      (inc (* dart-ct (last scores)))\n\n      :default\n      (letfn [(next-in-order []\n                (inc @gapless))\n              (throw-dart [dart-no score-so-far]\n                (when (pos? dart-no)\n                  (loop [[throw-score &amp; rthrows] scores]\n                    (when throw-score\n                      (let [new-total (+ score-so-far throw-score)]\n                        ;; we could pull the recursive call here since all branches of the cond\n                        ;; invoke it, but methinks that borders on obfuscation\n                        (cond\n                          (= new-total (next-in-order))\n                          (do\n                            (swap! gapless inc)\n                            ;; we keep going as an efficiency: if the next slice is one more\n                            ;; than the current slice, we can bump our gapless value straight away,\n                            ;; effectively pruning further searching.\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))\n\n                          (&gt; new-total (next-in-order))\n                          ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                          ;; and try the next, if any, which will possibly have access to lower values.\n                          (throw-dart (dec dart-no) new-total)\n\n                          :default                          ;; ie, new-total too low\n                          ;; try next dart if any and keep trying this dart\n                          (do\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))))))))]\n        (throw-dart dart-ct 0)\n        (next-in-order)))))&quot;, :offset 2558, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest darts\n  (let [board nil]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 1 (no-can-dart -1 board)))\n    (is (= 1 (no-can-dart 10 board))))\n  (let [board [2 3 4]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 1 (no-can-dart 1 board)))\n    (is (= 1 (no-can-dart 10 board))))\n  (let [board [1 2 3 4]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 5 (no-can-dart 1 board)))\n    (is (= 9 (no-can-dart 2 board))))\n  (let [board [1 3]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 2 (no-can-dart 1 board)))\n    (is (= 5 (no-can-dart 2 board)))\n    (is (= 8 (no-can-dart 3 board))))\n  (let [board [1 3 7]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 2 (no-can-dart 1 board)))\n    (is (= 5 (no-can-dart 2 board)))\n    (is (= 12 (no-can-dart 3 board))))\n  (let [board [1 4 7]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 2 (no-can-dart 1 board)))\n    (is (= 3 (no-can-dart 2 board)))\n    (is (= 10 (no-can-dart 3 board))))\n  (let [board [1 2 5 6]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 3 (no-can-dart 1 board)))\n    (is (= 9 (no-can-dart 2 board)))\n    (is (= 15 (no-can-dart 3 board)))))&quot;, :offset 1112, :ns &quot;spamgen.core-test&quot;} {:command &quot;#(no-can-dart [-2 -3 -7] 1)&quot;, :offset 27, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart\n  \&quot;Given a nmber of darts and the scores available on a dartboard, return\n  the lowest total score that cannot be scored. e.g., with one dart and\n  scores 1 and 3, we cannot score two. Withe two darts we cannot score 5.\n\n  Assumes scores are positive.\&quot;\n  [dart-ct dartboard-scores]\n\n  (let [scores (sort (distinct dartboard-scores))           ;; short for normalized scores\n        gapless (atom 0)]                                   ;; short for gapless max score observed as we traverse possible scoring combos\n    (cond\n      ;;; nail a couple of special cases\n      (or\n        (not (pos? dart-ct))\n        (empty? dartboard-scores)\n        (&gt; (first scores) 1))\n      1\n\n      ;; this one actually spares us a full sweep\n      (= dartboard-scores (range 1 (inc (count dartboard-scores))))\n      (inc (* dart-ct (last scores)))\n\n      :default\n      (letfn [(next-in-order []\n                (inc @gapless))\n              (throw-dart [dart-no score-so-far]\n                (when (pos? dart-no)\n                  (loop [[throw-score &amp; rthrows] scores]\n                    (when throw-score\n                      (let [new-total (+ score-so-far throw-score)]\n                        ;; we could pull the recursive call here since all branches of the cond\n                        ;; invoke it, but methinks that borders on obfuscation\n                        (cond\n                          (= new-total (next-in-order))\n                          (do\n                            (swap! gapless inc)\n                            ;; we keep going as an efficiency: if the next slice is one more\n                            ;; than the current slice, we can bump our gapless value straight away,\n                            ;; effectively pruning further searching.\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))\n\n                          (&gt; new-total (next-in-order))\n                          ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                          ;; and try the next, if any, which will possibly have access to lower values.\n                          (throw-dart (dec dart-no) new-total)\n\n                          :default                          ;; ie, new-total too low\n                          ;; try next dart if any and keep trying this dart\n                          (do\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))))))))]\n        (throw-dart dart-ct 0)\n        (next-in-order)))))&quot;, :offset 2584, :ns &quot;spamgen.core-test&quot;} {:command &quot;(count (email-records-test-gen 100000))&quot;, :offset 39, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-count\n   (p :test-gen-count\n     (count (email-records-test-gen 100000))))&quot;, :offset 92, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-count\n  (profile\n    {:dynamic? true}\n    (p :test-gen-count\n      (count (email-records-test-gen 100000))))\n   )&quot;, :offset 131, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-apit\n  (profile\n    {:dynamic? true}\n    (p :test-gen-count\n      (spit \&quot;testgen\&quot;(email-records-test-gen 100000)))))&quot;, :offset 134, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-apit\n  (profile\n    {:dynamic? true}\n    (p :test-gen-count\n      (spit \&quot;testgen.edn\&quot;\n        (into [] (email-records-test-gen 100000))))))&quot;, :offset 157, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-slurp\n  (profile\n    {:dynamic? true}\n    (p :test-gen-count\n      (slurp \&quot;testgen.edn\&quot;))))&quot;, :offset 109, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-count\n  (profile\n    {:dynamic? true}\n    (p :test-gen-count\n      (let [test (email-records-test-gen 10000)]\n        (pln :testing!)\n        (count test))\n      )))&quot;, :offset 183, :ns &quot;spamgen.core-test&quot;} {:command &quot;(s/def ::email-record\n  (s/keys :req-un [::email-address ::email-body ::spam-score]))&quot;, :offset 85, :ns &quot;spamgen.genlist&quot;} {:command &quot;(s/def ::email-record\n  (s/keys :req-un [::email-address  ::spam-score]))&quot;, :offset 73, :ns &quot;spamgen.genlist&quot;} {:command &quot;(spit (str \&quot;bulkinput/\&quot; 1000) (email-records-test-gen 1000))&quot;, :offset 60, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit (str \&quot;bulkinput/em-\&quot; 1000) (email-records-test-gen 1000))&quot;, :offset 63, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit (str \&quot;bulkinput/em-\&quot; 1000)\n      (into [] (email-records-test-gen 1000)))&quot;, :offset 79, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 100000)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 183, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit (str \&quot;bulkinput/em-\&quot; 1000 \&quot;.edn\&quot;)\n      (into [] (email-records-test-gen 1000)))&quot;, :offset 86, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [n 10]\n    (spit (str \&quot;bulkinput/em-\&quot; n \&quot;.edn\&quot;)\n      (into [] (email-records-test-gen n))))&quot;, :offset 97, :ns &quot;spamgen.core-test&quot;} {:command &quot;(slurp \&quot;bulkinput/em-1000.edn\&quot;)&quot;, :offset 31, :ns &quot;spamgen.core-test&quot;} {:command &quot;(edn/read-string\n  (slurp \&quot;bulkinput/em-1000.edn\&quot;))&quot;, :offset 51, :ns &quot;spamgen.core-test&quot;} {:command &quot;(first (edn/read-string\n         (slurp \&quot;bulkinput/em-1000.edn\&quot;)))&quot;, :offset 66, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3       \n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; n \&quot;.edn\&quot;) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 282, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3\n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; n \&quot;.edn\&quot;)\n               {:append (pos? n)}))\n        (range)\n        chunks))))&quot;, :offset 292, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3\n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               {:append (pos? n)}))\n        (range)\n        chunks))))&quot;, :offset 296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3\n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               c {:append (pos? n)}))\n        (range)\n        chunks))))&quot;, :offset 298, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3\n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               c :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3\n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 306, :ns &quot;spamgen.core-test&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.main">
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
    <configuration name="main" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="1" />
      <module name="spamgen" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="" />
      <created>1521628166875</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1521628166875</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="93" y="68" width="1425" height="886" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.49473685" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.13912475" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
    </layout>
    <layout-to-restore>
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.3435663" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.13912475" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
    </layout-to-restore>
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/test/spamgen/core_test.clj</url>
          <line>9</line>
          <properties />
          <option name="timeStamp" value="1" />
        </line-breakpoint>
      </breakpoints>
      <option name="time" value="7" />
    </breakpoint-manager>
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="153">
          <caret line="9" column="0" lean-forward="false" selection-start-line="9" selection-start-column="0" selection-end-line="9" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="17">
          <caret line="1" column="0" lean-forward="true" selection-start-line="1" selection-start-column="0" selection-end-line="1" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="18" lean-forward="true" selection-start-line="7" selection-start-column="18" selection-end-line="7" selection-end-column="18" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="249">
          <caret line="3207" column="10" lean-forward="false" selection-start-line="3207" selection-start-column="10" selection-end-line="3207" selection-end-column="10" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="357">
          <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/config/dev/config.edn">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="13" lean-forward="false" selection-start-line="7" selection-start-column="1" selection-end-line="7" selection-end-column="13" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="276">
          <caret line="40" column="17" lean-forward="true" selection-start-line="40" selection-start-column="17" selection-end-line="40" selection-end-column="17" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="230">
          <caret line="14" column="0" lean-forward="false" selection-start-line="14" selection-start-column="0" selection-end-line="14" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="377">
          <caret line="221" column="39" lean-forward="true" selection-start-line="221" selection-start-column="39" selection-end-line="221" selection-end-column="39" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>