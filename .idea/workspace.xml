<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="">
      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/src/dartgen/core.clj" />
      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/test/dartgen/core_test.clj" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/.idea/workspace.xml" afterPath="$PROJECT_DIR$/.idea/workspace.xml" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/test/spamgen/core_test.clj" afterPath="$PROJECT_DIR$/test/spamgen/core_test.clj" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="project.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="357">
              <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core_test.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="17">
              <caret line="15" column="0" lean-forward="false" selection-start-line="15" selection-start-column="0" selection-end-line="15" selection-end-column="0" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core_test.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/test/dartgen/core_test.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="85">
              <caret line="5" column="37" lean-forward="false" selection-start-line="5" selection-start-column="37" selection-end-line="5" selection-end-column="37" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="550">
              <caret line="302" column="0" lean-forward="false" selection-start-line="302" selection-start-column="0" selection-end-line="306" selection-end-column="20" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.clj" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/dartgen/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="648">
              <caret line="108" column="51" lean-forward="false" selection-start-line="108" selection-start-column="51" selection-end-line="108" selection-end-column="51" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
        <option value="Clojure Test Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>test-email-records</find>
      <find>println</find>
      <find>:sent</find>
      <find>env</find>
      <find>running-mean-ok?</find>
      <find>running-mean</find>
      <find>:rejected-span-mean</find>
      <find>:rejected-last-n</find>
      <find>:last-n-mean</find>
      <find>span-mean</find>
      <find>:max-overall-spam-score</find>
      <find>:overall-mean-max</find>
      <find>:individual-max</find>
      <find>:score-sum</find>
      <find>:total-email-ct</find>
      <find>:rejected-</find>
      <find>:max-individual-spam-score</find>
      <find>RV</find>
      <find>rejected-abs</find>
      <find>em-ct</find>
      <find>out-file</find>
      <find>spitter</find>
      <find>slices</find>
      <find>got</find>
      <find>no-can-dart</find>
    </findStrings>
    <replaceStrings>
      <replace>em-addrs-hit</replace>
      <replace>:addrs-hit</replace>
      <replace>*env*</replace>
      <replace>span-mean-ok</replace>
      <replace>:rejected-span-mean</replace>
      <replace>last-n-mean</replace>
      <replace>last-n-span</replace>
      <replace>env-hack</replace>
      <replace>:span-mean</replace>
      <replace>last-n</replace>
      <replace>:overall-mean-max</replace>
      <replace>:spam-score-sum</replace>
      <replace>:individual-max</replace>
      <replace>XXX</replace>
      <replace>RV</replace>
      <replace>:rejected-overall-mean</replace>
      <replace>XX</replace>
      <replace>rejected-score</replace>
      <replace>sent-ct</replace>
      <replace>scores</replace>
      <replace>board</replace>
      <replace>spit-file</replace>
      <replace>low-score-unattainable</replace>
    </replaceStrings>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/resources/config.edn" />
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/config/dev/config.edn" />
        <option value="$PROJECT_DIR$/src/spamgen/genlist.clj" />
        <option value="$PROJECT_DIR$/src/spamgen/core.clj" />
        <option value="$PROJECT_DIR$/test/spamgen/core_test.clj" />
        <option value="$PROJECT_DIR$/test/dartgen/core_test.clj" />
        <option value="$PROJECT_DIR$/src/dartgen/core.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds">
    <option name="x" value="93" />
    <option name="y" value="68" />
    <option name="width" value="1544" />
    <option name="height" value="886" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="AndroidView" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
              <item name="dev" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="dartgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="dartgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="Scope" />
      <pane id="PackagesPane" />
      <pane id="Scratches" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="preferences.keymap" />
    <property name="cursive.last.file.extension./Users/kennethtilton/spamgen/src" value="clj" />
    <property name="cursive.last.file.extension./Users/kennethtilton/spamgen/test" value="clj" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/config/dev" />
    </key>
  </component>
  <component name="ReplState" timestamp="1522075831240">{:repl-history {:ide [], :local [{:command &quot;(defn board\n  ([slices max] (board slices 1 max []))\n  ([slices min max board-so-far]\n   (when (&lt; min max)\n     (cond\n       (zero? slices)\n       (pln board-so-far)\n\n       :default\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc min) max (conj board-so-far score)))))))&quot;, :offset 301, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 1 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln board-so-far)\n\n     :default\n     (do\n       (pln :seq min max)\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc min) max (conj board-so-far score)))))))&quot;, :offset 307, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 1 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln board-so-far)\n\n     :default\n     (do\n       (pln :seq min max)\n       (doseq [score (range (inc min) (inc max))]\n         (board (dec slices) score max (conj board-so-far score)))))))&quot;, :offset 309, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 1 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln board-so-far)\n\n     :default\n     (do\n       (pln :seq min max)\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 309, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 1 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln board-so-far)\n\n     :default\n     (do\n       ;(pln :seq min max)\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 310, :ns &quot;dartgen.core&quot;} {:command &quot;(board 2 3)&quot;, :offset 11, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 1 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln :f board-so-far)\n\n     :default\n     (do\n       (pln :p board)\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 308, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 1 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln :f board-so-far)\n\n     :default\n     (do\n       (pln :p board-so-far)\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 315, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 1 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln :f board-so-far)\n\n     :default\n     (do\n       (when-not (empty? (pln :p board-so-far)))\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 335, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 1 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln :f board-so-far)\n\n     :default\n     (do\n       (when-not (empty? board-so-far)\n         (pln :p board-so-far))\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 357, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 1 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln :f board-so-far)\n\n     :default\n     (do\n       #_ (when-not (empty? board-so-far) \n            (pln :p board-so-far))\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 364, :ns &quot;dartgen.core&quot;} {:command &quot;(board 3 3)&quot;, :offset 11, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 2 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln :f (conj board-so-far 1))\n\n     :default\n     (do\n       #_ (when-not (empty? board-so-far) \n            (pln :p board-so-far))\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 373, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 2 max []))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln :f board-so-far)\n\n     :default\n     (do\n       #_ (when-not (empty? board-so-far) \n            (pln :p board-so-far))\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 364, :ns &quot;dartgen.core&quot;} {:command &quot;(board 3 4)&quot;, :offset 11, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board slices 2 max [1]))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln :f board-so-far)\n\n     :default\n     (do\n       #_ (when-not (empty? board-so-far) \n            (pln :p board-so-far))\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 365, :ns &quot;dartgen.core&quot;} {:command &quot;(board 3 5)&quot;, :offset 11, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board\n  ([slices max] (board (dec slices) 2 max [1]))\n  ([slices min max board-so-far]\n   (cond\n     (zero? slices)\n     (pln :f board-so-far)\n\n     :default\n     (do\n       #_ (when-not (empty? board-so-far) \n            (pln :p board-so-far))\n       (doseq [score (range min (inc max))]\n         (board (dec slices) (inc score) max (conj board-so-far score)))))))&quot;, :offset 371, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board [slices max]\n  (letfn [(rboard [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (pln :f board-so-far)\n\n              :default\n              (do\n                #_ (when-not (empty? board-so-far)\n                     (pln :p board-so-far))\n                (doseq [score (range min (inc max))]\n                  (board (dec slices)\n                    (inc score) max\n                    (conj board-so-far score))))))]\n    (board (dec slices) 2 max [1])))&quot;, :offset 508, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board [slices max]\n  (letfn [(rboard [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (pln :f board-so-far)\n\n              :default\n              (do\n                #_ (when-not (empty? board-so-far)\n                     (pln :p board-so-far))\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score))))))]\n    (board (dec slices) 2 max [1])))&quot;, :offset 509, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board [slices max]\n  (letfn [(rboard [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (pln :f board-so-far)\n\n              :default\n              (do\n                #_ (when-not (empty? board-so-far)\n                     (pln :p board-so-far))\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score))))))]\n    (rboard (dec slices) 2 max [1])))&quot;, :offset 510, :ns &quot;dartgen.core&quot;} {:command &quot;(board 3 6)&quot;, :offset 11, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max fn]\n  (letfn [(rboard [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (fn board-so-far)\n\n              :default\n              (do\n                #_ (when-not (empty? board-so-far)\n                     (pln :p board-so-far))\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score))))))]\n    (rboard (dec slices) 2 max [1])))&quot;, :offset 514, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 3 6 println)&quot;, :offset 24, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 3 6 #(no-can-dart % 2))&quot;, :offset 35, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 3 6 #(no-can-dart 2 %))&quot;, :offset 35, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 3 6 #(pn (no-can-dart 2 %)))&quot;, :offset 40, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 3 6 #(pln (no-can-dart 2 %)))&quot;, :offset 41, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 3 6 #(pln (no-can-dart 2 %) %))&quot;, :offset 43, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 4 6 #(pln (no-can-dart 2 %) %))&quot;, :offset 43, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 5 6 #(pln (no-can-dart 2 %) %))&quot;, :offset 43, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 3 10 #(pln (no-can-dart 2 %) %))&quot;, :offset 44, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max fn]\n  (let [best (atom nil) \n        rboard\n        (fn [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (let [r (fn board-so-far)]\n                (when (or (nil? @best)\n                        (&gt; r (first @best)))\n                  (rest! best (conj r board))))\n\n              :default\n              (do\n                #_ (when-not (empty? board-so-far)\n                     (pln :p board-so-far))\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score))))))]\n    (rboard (dec slices) 2 max [1])))&quot;, :offset 689, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max fn]\n  (let [best (atom nil) \n        rboard\n        (fn [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (let [r (fn board-so-far)]\n                (when (or (nil? @best)\n                        (&gt; r (first @best)))\n                  (rest! best (conj r board-so-far))))\n\n              :default\n              (do\n                #_ (when-not (empty? board-so-far)\n                     (pln :p board-so-far))\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score))))))]\n    (rboard (dec slices) 2 max [1])))&quot;, :offset 696, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max fn]\n  (let [best (atom nil)\n        rboard\n        (fn [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (let [r (fn board-so-far)]\n                (when (or (nil? @best)\n                        (&gt; r (first @best)))\n                  (rest! best (conj r board-so-far))))\n\n              :default\n              (do\n                #_ (when-not (empty? board-so-far)\n                     (pln :p board-so-far))\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score))))))]\n    (rboard (dec slices) 2 max [1])))&quot;, :offset 695, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max fn]\n  (let [best (atom nil)\n        rboard\n        (fn [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (let [r (fn board-so-far)]\n                (when (or (nil? @best)\n                        (&gt; r (first @best)))\n                  (reset! best (conj r board-so-far))))\n\n              :default\n              (do\n                #_ (when-not (empty? board-so-far)\n                     (pln :p board-so-far))\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score))))))]\n    (rboard (dec slices) 2 max [1])))&quot;, :offset 696, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max fn]\n  (let [best (atom nil)\n        rboard\n        (fn [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (let [r (fn board-so-far)]\n                (when (or (nil? @best)\n                        (&gt; r (first @best)))\n                  (reset! best (conj r board-so-far))))\n\n              :default\n              (do)))]\n    (rboard (dec slices) 2 max [1])))&quot;, :offset 425, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max score-fn]\n  (let [best (atom nil)\n        rboard\n        (fn [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (let [r (score-fn board-so-far)]\n                (when (or (nil? @best)\n                        (&gt; r (first @best)))\n                  (reset! best (conj r board-so-far))))\n\n              :default\n              (do)))]\n    (rboard (dec slices) 2 max [1])))&quot;, :offset 437, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max score-fn]\n  (let [best (atom nil)\n        rboard\n        (fn [slices min max board-so-far]\n            (cond\n              (zero? slices)\n              (let [r (score-fn board-so-far)]\n                (when (or (nil? @best)\n                        (&gt; r (first @best)))\n                  (reset! best (conj r board-so-far))))\n\n              :default\n              (doseq [score (range min (inc max))]\n                (rboard (dec slices)\n                  (inc score) max\n                  (conj board-so-far score)))))]\n    \n    (rboard (dec slices) 2 max [1])))&quot;, :offset 591, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max score-fn]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              (cond\n                (zero? slices)\n                (let [r (score-fn board-so-far)]\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    (reset! best (conj r board-so-far))))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1]))))&quot;, :offset 605, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max score-fn]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              (pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (score-fn board-so-far)]\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    (reset! best (conj r board-so-far))))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1]))))&quot;, :offset 658, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 4 10 #(pln (no-can-dart 2 %) %))&quot;, :offset 44, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 4 10 #([(no-can-dart 2 %) %]))&quot;, :offset 42, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max score-fn]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              (pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (score-fn board-so-far)]\n                  (pln :sco!!! r)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    (reset! best (conj r board-so-far))))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1]))))&quot;, :offset 692, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max score-fn]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              (pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (score-fn board-so-far)]\n                  (pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    (pln :better! r board-so-far)\n                    (reset! best (conj r board-so-far))))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1]))))&quot;, :offset 748, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max score-fn]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              (pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (score-fn board-so-far)]\n                  (pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    (pln :better! r board-so-far)\n                    (reset! best [r board-so-far])))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1]))))&quot;, :offset 743, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max score-fn]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              ;(pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (score-fn board-so-far)]\n                  ;(pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    (pln :better! r board-so-far)\n                    (reset! best [r board-so-far])))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1]))))&quot;, :offset 745, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 4 10 #(no-can-dart 2 %))&quot;, :offset 36, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 4 20 #(no-can-dart 2 %))&quot;, :offset 36, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max score-fn]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              ;(pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (score-fn board-so-far)]\n                  ;(pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    (pln :better! r board-so-far)\n                    (reset! best [r board-so-far])))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1])\n      @best)))&quot;, :offset 757, :ns &quot;dartgen.core&quot;} {:command &quot;(boards-try 4 20 #(no-can-dart 3 %))&quot;, :offset 36, :ns &quot;dartgen.core&quot;} {:command &quot;(defn boards-try [slices max score-fn]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              ;(pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (score-fn board-so-far)]\n                  ;(pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    ;(pln :better! r board-so-far)\n                    (reset! best [r board-so-far])))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1])\n      @best)))&quot;, :offset 758, :ns &quot;dartgen.core&quot;} {:command &quot;(doseq [mx (range 10 20)]\n  (pln :mx mx (boards-try 4 20 #(no-can-dart 3 %))))&quot;, :offset 78, :ns &quot;dartgen.core&quot;} {:command &quot;(doseq [mx (range 10 20)]\n  (pln :mx mx (boards-try 4 mx #(no-can-dart 3 %))))&quot;, :offset 78, :ns &quot;dartgen.core&quot;} {:command &quot;(doseq [mx (range 10 20)]\n  (pln :mx mx (boards-try 5 mx #(no-can-dart 3 %))))&quot;, :offset 78, :ns &quot;dartgen.core&quot;} {:command &quot;(doseq [mx (range 10 30)]\n  (pln :mx mx (boards-try 5 mx #(no-can-dart 3 %))))&quot;, :offset 78, :ns &quot;dartgen.core&quot;} {:command &quot;(doseq [mx (range 10 30)]\n  (pln :mx mx (boards-try 6 mx #(no-can-dart 3 %))))&quot;, :offset 78, :ns &quot;dartgen.core&quot;} {:command &quot;(doseq [mx (range 10 30)]\n  (pln :mx mx (boards-try 7 mx #(no-can-dart 3 %))))&quot;, :offset 78, :ns &quot;dartgen.core&quot;} {:command &quot;(doseq [mx (range 10 50)]\n  (pln :mx mx (boards-try 7 mx #(no-can-dart 3 %))))&quot;, :offset 78, :ns &quot;dartgen.core&quot;} {:command &quot;(let [board-score-ct 5 ;; ie, how many slices in the board \&quot;pie\&quot;\n      darts 3\n      max-scores-to-try (range 10 30)]\n  (doseq [mx max-scores-to-try]\n    (pln :mx mx (boards-try board-score-ct mx #(no-can-dart darts %)))))&quot;, :offset 222, :ns &quot;dartgen.core&quot;} {:command &quot;(defn low-score-unattainable\n  \&quot;Given a nmber of darts and the scores available on a dartboard, return\n  the lowest total score that cannot be scored. e.g., with one dart and\n  scores 1 and 3, we cannot score two. Withe two darts we cannot score 5.\n\n  Assumes scores are positive.\&quot;\n\n  [dart-ct dartboard-scores]\n\n  (let [scores (sort (distinct dartboard-scores))           ;; short for normalized scores\n        gapless (atom 0)]                                   ;; short for gapless max score observed as we traverse possible scoring combos\n    (cond\n      ;;; nail a couple of special cases\n      (or\n        (not (pos? dart-ct))\n        (empty? dartboard-scores)\n        (&gt; (first scores) 1))\n      1\n\n      ;; this one actually spares us a full sweep\n      (= dartboard-scores (range 1 (inc (count dartboard-scores))))\n      (inc (* dart-ct (last scores)))\n\n      :default\n      (letfn [(next-in-order []\n                (inc @gapless))\n              (throw-dart [dart-no score-so-far]\n                (when (pos? dart-no)\n                  (loop [[throw-score &amp; rthrows] scores]\n                    (when throw-score\n                      (let [new-total (+ score-so-far throw-score)]\n                        ;; we could pull the recursive call here since all branches of the cond\n                        ;; invoke it, but methinks that borders on obfuscation\n                        (cond\n                          (= new-total (next-in-order))\n                          (do\n                            (swap! gapless inc)\n                            ;; we keep going as an efficiency: if the next slice is one more\n                            ;; than the current slice, we can bump our gapless value straight away,\n                            ;; effectively pruning further searching.\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))\n\n                          (&gt; new-total (next-in-order))\n                          ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                          ;; and try the next, if any, which will possibly have access to lower values.\n                          (throw-dart (dec dart-no) new-total)\n\n                          :default                          ;; ie, new-total too low\n                          ;; try next dart if any and keep trying this dart\n                          (do\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))))))))]\n        (throw-dart dart-ct 0)\n        (next-in-order)))))&quot;, :offset 2596, :ns &quot;dartgen.core&quot;} {:command &quot;(defn highest-unattainable-board [slices darts max score-fn]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              ;(pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (low-score-unattainable darts board-so-far)]\n                  ;(pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    ;(pln :better! r board-so-far)\n                    (reset! best [r board-so-far])))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1])\n      @best)))&quot;, :offset 800, :ns &quot;dartgen.core&quot;} {:command &quot;(defn highest-unattainable-board [slices darts max]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              ;(pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (low-score-unattainable darts board-so-far)]\n                  ;(pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    ;(pln :better! r board-so-far)\n                    (reset! best [r board-so-far])))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1])\n      @best)))&quot;, :offset 791, :ns &quot;dartgen.core&quot;} {:command &quot;(highest-unattainable-board 4 3 30)&quot;, :offset 35, :ns &quot;dartgen.core&quot;} {:command &quot;(defn scoring-yielding-highest-unattainable [slices darts max]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              ;(pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (low-score-unattainable darts board-so-far)]\n                  ;(pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    ;(pln :better! r board-so-far)\n                    (reset! best [r board-so-far])))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1])\n      @best)))&quot;, :offset 802, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable [slices darts max]\n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              ;(pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (low-score-unattainable darts board-so-far)]\n                  ;(pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    ;(pln :better! r board-so-far)\n                    (reset! best [r board-so-far])))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1])\n      @best)))&quot;, :offset 800, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and max inclusive\n  and a number of darts, determine the board scoring yielding\n  the highest unattainable score.\&quot;\n  [slices darts max]\n  \n  (let [best (atom nil)]\n    (letfn [(rboard [slices min max board-so-far]\n              ;(pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (low-score-unattainable darts board-so-far)]\n                  ;(pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    ;(pln :better! r board-so-far)\n                    (reset! best [r board-so-far])))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) 2 max [1])\n      @best)))&quot;, :offset 1021, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable 4 3 30)&quot;, :offset 44, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and max inclusive\n  and a number of darts, determine the board scoring yielding\n  the highest unattainable score.\&quot;\n  ([slices darts max]\n   (board-yielding-highest-unattainable slices darts 2 maxi))\n  \n  ([slices darts mini maxi])\n  \n  (let [best (atom nil)]\n    (letfn [(rboard [slices mini maxi board-so-far]\n              ;(pln :top slices min max board-so-far)\n              (cond\n                (zero? slices)\n                (let [r (low-score-unattainable darts board-so-far)]\n                  ;(pln :sco!!! r @best)\n                  (when (or (nil? @best)\n                          (&gt; r (first @best)))\n                    ;(pln :better! r board-so-far)\n                    (reset! best [r board-so-far])))\n\n                :default\n                (doseq [score (range min (inc max))]\n                  (rboard (dec slices)\n                    (inc score) max\n                    (conj board-so-far score)))))]\n      (rboard (dec slices) mini maxi [1])\n      @best)))&quot;, :offset 1122, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and max inclusive\n  and a number of darts, determine the board scoring yielding\n  the highest unattainable score.\&quot;\n  ([slices darts max]\n   (board-yielding-highest-unattainable slices darts 2 maxi))\n\n  ([slices darts mini maxi]\n\n   (let [best (atom nil)]\n     (letfn [(rboard [slices mini maxi board-so-far]\n               ;(pln :top slices min max board-so-far)\n               (cond\n                 (zero? slices)\n                 (let [r (low-score-unattainable darts board-so-far)]\n                   ;(pln :sco!!! r @best)\n                   (when (or (nil? @best)\n                           (&gt; r (first @best)))\n                     ;(pln :better! r board-so-far)\n                     (reset! best [r board-so-far])))\n\n                 :default\n                 (doseq [score (range min (inc max))]\n                   (rboard (dec slices)\n                     (inc score) max\n                     (conj board-so-far score)))))]\n       (rboard (dec slices) mini maxi [1])\n       @best))))&quot;, :offset 1136, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and max inclusive\n  and a number of darts, determine the board scoring yielding\n  the highest unattainable score.\&quot;\n  ([slices darts maxi]\n   (board-yielding-highest-unattainable slices darts 2 maxi))\n\n  ([slices darts mini maxi]\n\n   (let [best (atom nil)]\n     (letfn [(rboard [slices mini maxi board-so-far]\n               ;(pln :top slices min max board-so-far)\n               (cond\n                 (zero? slices)\n                 (let [r (low-score-unattainable darts board-so-far)]\n                   ;(pln :sco!!! r @best)\n                   (when (or (nil? @best)\n                           (&gt; r (first @best)))\n                     ;(pln :better! r board-so-far)\n                     (reset! best [r board-so-far])))\n\n                 :default\n                 (doseq [score (range min (inc max))]\n                   (rboard (dec slices)\n                     (inc score) max\n                     (conj board-so-far score)))))]\n       (rboard (dec slices) mini maxi [1])\n       @best))))&quot;, :offset 1137, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and maxi inclusive\n  and a number of darts, determine (kinda -- see next) the board scoring yielding\n  the highest unattainable score.\n\n  Actually just tries maxi between mini and maxi. If one sets maxi too\n  low, higher unattainabes will be missed. The unattainable does max out\n  if one sets the maxi high enough, but we have observed the unattainable\n  levelling out for five maxis and then picking up again. Left as an exercise\n  is determining when higher maxis will not yield a higher unattainable.\&quot;\n\n  ([slices darts maxi]\n   (board-yielding-highest-unattainable slices darts 2 maxi))\n\n  ([slices darts mini maxi]\n\n   (let [best (atom nil)]\n     (letfn [(rboard [slices mini maxi board-so-far]\n               ;(pln :top slices min max board-so-far)\n               (cond\n                 (zero? slices)\n                 (let [r (low-score-unattainable darts board-so-far)]\n                   ;(pln :sco!!! r @best)\n                   (when (or (nil? @best)\n                           (&gt; r (first @best)))\n                     ;(pln :better! r board-so-far)\n                     (reset! best [r board-so-far])))\n\n                 :default\n                 (doseq [score (range mini (inc maxi))]\n                   (rboard (dec slices)\n                     (inc score) maxi\n                     (conj board-so-far score)))))]\n       (rboard (dec slices) mini maxi [1])\n       @best))))&quot;, :offset 1532, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable 32 3 30)&quot;, :offset 45, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable 10 3 30)&quot;, :offset 45, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable 5 3 30)&quot;, :offset 44, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable 6 3 30)&quot;, :offset 44, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable 7 3 30)&quot;, :offset 44, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and maxi inclusive\n  and a number of darts, determine (kinda -- see next) the board scoring yielding\n  the highest unattainable score.\n\n  Actually just tries maxi between mini and maxi. If one sets maxi too\n  low, higher unattainabes will be missed. The unattainable does max out\n  if one sets the maxi high enough, but we have observed the unattainable\n  levelling out for five maxis and then picking up again. Left as an exercise\n  is determining when higher maxis will not yield a higher unattainable.\n\n  Top-level playground follows code.\&quot;\n\n  ([slices darts maxi]\n   (board-yielding-highest-unattainable slices darts 2 maxi))\n\n  ([slices darts mini maxi]\n\n   (let [best (atom nil)]\n     (letfn [(rboard [slices mini maxi board-so-far]\n               (cond\n                 (zero? slices)\n                 (let [r (low-score-unattainable darts board-so-far)]\n                   (when (or (nil? @best)\n                           (&gt; r (first @best)))\n                     (reset! best [r board-so-far])))\n\n                 :default\n                 (doseq [score (range mini (inc maxi))]\n                   (rboard (dec slices)\n                     (inc score) maxi\n                     (conj board-so-far score)))))]\n       (rboard (dec slices) mini maxi [1])\n       @best))))&quot;, :offset 1421, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and maxi inclusive\n  and a number of darts, determine (kinda -- see next) the board scoring yielding\n  the highest unattainable score.\n\n  Actually just tries maxi between mini and maxi. If one sets maxi too\n  low, higher unattainabes will be missed. The unattainable does max out\n  if one sets the maxi high enough, but we have observed the unattainable\n  levelling out for five maxis and then picking up again. Left as an exercise\n  is determining when higher maxis will not yield a higher unattainable.\n\n  Top-level playground follows code.\&quot;\n\n  ([slices darts maxi]\n   (board-yielding-highest-unattainable slices darts 2 maxi))\n\n  ([slices darts mini maxi]\n\n   (let [best (atom nil)]\n     (letfn [(rboard [slices mini maxi board-so-far]\n               (cond\n                 (zero? slices)\n                 (let [r (low-score-unattainable darts board-so-far)]\n                   (when (or (nil? @best)\n                           (&gt; r (first @best)))\n                     (pln :new-best! r board-so-far)\n                     (reset! best [r board-so-far])))\n\n                 :default\n                 (doseq [score (range mini (inc maxi))]\n                   (rboard (dec slices)\n                     (inc score) maxi\n                     (conj board-so-far score)))))]\n       (rboard (dec slices) mini maxi [1])\n       @best))))&quot;, :offset 1474, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable 8 3 30)&quot;, :offset 44, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable 8 3 35)&quot;, :offset 44, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable 8 3 40)&quot;, :offset 44, :ns &quot;dartgen.core&quot;} {:command &quot;(merge {:a 2} {:a 3})&quot;, :offset 21, :ns &quot;dartgen.core&quot;} {:command &quot;(let [(:keys [a b]) {:a 42 :c 7}]\n  (list a b))&quot;, :offset 47, :ns &quot;dartgen.core&quot;} {:command &quot;(let [(keys [a b]) {:a 42 :c 7}]\n  (list a b))&quot;, :offset 46, :ns &quot;dartgen.core&quot;} {:command &quot;(let [{:keys [a b]} {:a 42 :c 7}]\n  (list a b))&quot;, :offset 47, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and maxi inclusive\n  and a number of darts, determine (kinda -- see next) the board scoring yielding\n  the highest unattainable score.\n\n  Actually just tries maxi between mini and maxi. If one sets maxi too\n  low, higher unattainabes will be missed. The unattainable does max out\n  if one sets the maxi high enough, but we have observed the unattainable\n  levelling out for five maxis and then picking up again. Left as an exercise\n  is determining when higher maxis will not yield a higher unattainable.\n\n  Top-level playground follows code.\&quot;\n\n  [options]\n  (let [\n        {:keys [slices darts mini maxi]}\n        (merge {:slices 5 :darts 3 :mini 2 :maxi 30} options)]\n\n   (let [best (atom nil)]\n     (letfn [(rboard [slices mini maxi board-so-far]\n               (cond\n                 (zero? slices)\n                 (let [r (low-score-unattainable darts board-so-far)]\n                   (when (or (nil? @best)\n                           (&gt; r (first @best)))\n                     (pln :new-best! r board-so-far)\n                     (reset! best [r board-so-far])))\n\n                 :default\n                 (doseq [score (range mini (inc maxi))]\n                   (rboard (dec slices)\n                     (inc score) maxi\n                     (conj board-so-far score)))))]\n       (rboard (dec slices) mini maxi [1])\n       @best))))&quot;, :offset 1485, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable {:slices 6\n                                          :darts 3\n                                          :maxi 20})&quot;, :offset 151, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and maxi inclusive\n  and a number of darts, determine (kinda -- see next) the board scoring yielding\n  the highest unattainable score.\n\n  Actually just tries maxi between mini and maxi. If one sets maxi too\n  low, higher unattainabes will be missed. The unattainable does max out\n  if one sets the maxi high enough, but we have observed the unattainable\n  levelling out for five maxis and then picking up again. Left as an exercise\n  is determining when higher maxis will not yield a higher unattainable.\n\n  Top-level playground follows code.\&quot;\n  ([] (board-yielding-highest-unattainable {:slices 5 :darts 3 :mini 2 :maxi 30}))\n\n  ([options]\n   (let [\n         {:keys [slices darts mini maxi]}\n         (merge {:slices 5 :darts 3 :mini 2 :maxi 30} options)]\n\n     (let [best (atom nil)]\n       (letfn [(rboard [slices mini maxi board-so-far]\n                 (cond\n                   (zero? slices)\n                   (let [r (low-score-unattainable darts board-so-far)]\n                     (when (or (nil? @best)\n                             (&gt; r (first @best)))\n                       (pln :new-best! r board-so-far)\n                       (reset! best [r board-so-far])))\n\n                   :default\n                   (doseq [score (range mini (inc maxi))]\n                     (rboard (dec slices)\n                       (inc score) maxi\n                       (conj board-so-far score)))))]\n         (rboard (dec slices) mini maxi [1])\n         @best)))))&quot;, :offset 1605, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and maxi inclusive\n  and a number of darts, determine (kinda -- see next) the board scoring yielding\n  the highest unattainable score.\n\n  Actually just tries maxi between mini and maxi. If one sets maxi too\n  low, higher unattainabes will be missed. The unattainable does max out\n  if one sets the maxi high enough, but we have observed the unattainable\n  levelling out for five maxis and then picking up again. Left as an exercise\n  is determining when higher maxis will not yield a higher unattainable.\n\n  Top-level playground follows code.\&quot;\n  ([] (recur {:slices 5 :darts 3 :mini 2 :maxi 30}))\n\n  ([options]\n   (let [\n         {:keys [slices darts mini maxi]}\n         (merge {:slices 5 :darts 3 :mini 2 :maxi 30} options)]\n\n     (let [best (atom nil)]\n       (letfn [(rboard [slices mini maxi board-so-far]\n                 (cond\n                   (zero? slices)\n                   (let [r (low-score-unattainable darts board-so-far)]\n                     (when (or (nil? @best)\n                             (&gt; r (first @best)))\n                       (pln :new-best! r board-so-far)\n                       (reset! best [r board-so-far])))\n\n                   :default\n                   (doseq [score (range mini (inc maxi))]\n                     (rboard (dec slices)\n                       (inc score) maxi\n                       (conj board-so-far score)))))]\n         (rboard (dec slices) mini maxi [1])\n         @best)))))&quot;, :offset 1575, :ns &quot;dartgen.core&quot;} {:command &quot;board-yielding-highest-unattainable&quot;, :offset 35, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable)&quot;, :offset 37, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable {:slices 6\n                                          ;;:darts  3\n                                          :maxi   20})&quot;, :offset 156, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable {:slices 6\n                                          :darts  3\n                                          :maxi   20})&quot;, :offset 154, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable {:slices 6\n                                          :maxi   20})&quot;, :offset 102, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable {:slices 8\n                                          :maxi   20})&quot;, :offset 102, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable {:slices 10\n                                          :maxi   20})&quot;, :offset 103, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable {:slices 15\n                                          :maxi   20})&quot;, :offset 103, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable {:slices 20\n                                          :maxi   20})&quot;, :offset 103, :ns &quot;dartgen.core&quot;} {:command &quot;(board-yielding-highest-unattainable {:slices 20\n                                          :maxi   30})&quot;, :offset 103, :ns &quot;dartgen.core&quot;} {:command &quot;(defn board-yielding-highest-unattainable\n  \&quot;Given a dart board with 'slices' hittable scores not\n  necessarily numbered in sequence between 1 and maxi inclusive\n  and a number of darts, determine (kinda -- see next) the board scoring yielding\n  the highest unattainable score.\n\n  Actually just tries maxi between mini and maxi. If one sets maxi too\n  low, higher unattainabes will be missed. The unattainable does max out\n  if one sets the maxi high enough, but we have observed the unattainable\n  levelling out for five maxis and then picking up again. Left as an exercise\n  is determining when higher maxis will not yield a higher unattainable.\n\n  Top-level playground follows code.\&quot;\n  ([] (board-yielding-highest-unattainable {:slices 5 :darts 3 :mini 2 :maxi 30}))\n\n  ([options]\n   (let [\n         {:keys [slices darts mini maxi verbose]}\n         (merge {:slices 5 :darts 3 :mini 2 :maxi 30} options)]\n\n     (let [best (atom nil)]\n       (letfn [(rboard [slices mini maxi board-so-far]\n                 (when-not (and @best\n                              (= (first best) (inc (* darts maxi))))\n                 (cond\n                   (zero? slices)\n                   (let [r (low-score-unattainable darts board-so-far)]\n                     (when (or (nil? @best)\n                             (&gt; r (first @best)))\n                       (when verbose (pln :new-best! r board-so-far))\n                       (reset! best [r board-so-far])))\n\n                   :default\n                   (doseq [score (range mini (inc maxi))]\n                     (rboard (dec slices)\n                       (inc score) maxi\n                       (conj board-so-far score))))))]\n         (rboard (dec slices) mini maxi [1])\n         @best)))))&quot;, :offset 1736, :ns &quot;dartgen.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.main">
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
    <configuration name="main" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="1" />
      <module name="spamgen" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="" />
      <created>1521628166875</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1521628166875</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="93" y="68" width="1544" height="886" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.2972798" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.13860103" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
    </layout>
    <layout-to-restore>
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.3435663" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.13912475" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
    </layout-to-restore>
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <option name="time" value="11" />
    </breakpoint-manager>
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="153">
          <caret line="9" column="0" lean-forward="false" selection-start-line="9" selection-start-column="0" selection-end-line="9" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="17">
          <caret line="1" column="0" lean-forward="true" selection-start-line="1" selection-start-column="0" selection-end-line="1" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="18" lean-forward="true" selection-start-line="7" selection-start-column="18" selection-end-line="7" selection-end-column="18" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="249">
          <caret line="3207" column="10" lean-forward="false" selection-start-line="3207" selection-start-column="10" selection-end-line="3207" selection-end-column="10" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/config/dev/config.edn">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="13" lean-forward="false" selection-start-line="7" selection-start-column="1" selection-end-line="7" selection-end-column="13" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="276">
          <caret line="40" column="17" lean-forward="true" selection-start-line="40" selection-start-column="17" selection-end-line="40" selection-end-column="17" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="357">
          <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="550">
          <caret line="302" column="0" lean-forward="false" selection-start-line="302" selection-start-column="0" selection-end-line="306" selection-end-column="20" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="17">
          <caret line="15" column="0" lean-forward="false" selection-start-line="15" selection-start-column="0" selection-end-line="15" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/dartgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="85">
          <caret line="5" column="37" lean-forward="false" selection-start-line="5" selection-start-column="37" selection-end-line="5" selection-end-column="37" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/dartgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="648">
          <caret line="108" column="51" lean-forward="false" selection-start-line="108" selection-start-column="51" selection-end-line="108" selection-end-column="51" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>