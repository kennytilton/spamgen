<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="">
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/src/spamgen/core.clj" afterPath="$PROJECT_DIR$/src/spamgen/core.clj" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/src/spamgen/genlist.clj" afterPath="$PROJECT_DIR$/src/spamgen/genlist.clj" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/test/spamgen/core_test.clj" afterPath="$PROJECT_DIR$/test/spamgen/core_test.clj" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="project.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="357">
              <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="config.edn" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/config/dev/config.edn">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="119">
              <caret line="7" column="13" lean-forward="false" selection-start-line="7" selection-start-column="1" selection-end-line="7" selection-end-column="13" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core_test.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="272">
              <caret line="16" column="20" lean-forward="true" selection-start-line="16" selection-start-column="20" selection-end-line="16" selection-end-column="20" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.clj" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="273">
              <caret line="190" column="11" lean-forward="false" selection-start-line="190" selection-start-column="11" selection-end-line="190" selection-end-column="11" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="genlist.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="259">
              <caret line="36" column="16" lean-forward="false" selection-start-line="36" selection-start-column="16" selection-end-line="36" selection-end-column="16" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>test-email-records</find>
      <find>println</find>
      <find>:sent</find>
      <find>env</find>
      <find>running-mean-ok?</find>
      <find>running-mean</find>
      <find>:rejected-span-mean</find>
      <find>:rejected-last-n</find>
      <find>:last-n-mean</find>
      <find>span-mean</find>
      <find>:max-overall-spam-score</find>
      <find>:overall-mean-max</find>
      <find>:individual-max</find>
      <find>:score-sum</find>
      <find>:total-email-ct</find>
      <find>:rejected-</find>
      <find>:max-individual-spam-score</find>
      <find>RV</find>
      <find>rejected-abs</find>
      <find>em-ct</find>
    </findStrings>
    <replaceStrings>
      <replace>em-addrs-hit</replace>
      <replace>:addrs-hit</replace>
      <replace>*env*</replace>
      <replace>span-mean-ok</replace>
      <replace>:rejected-span-mean</replace>
      <replace>last-n-mean</replace>
      <replace>last-n-span</replace>
      <replace>env-hack</replace>
      <replace>:span-mean</replace>
      <replace>last-n</replace>
      <replace>:overall-mean-max</replace>
      <replace>:spam-score-sum</replace>
      <replace>:individual-max</replace>
      <replace>XXX</replace>
      <replace>RV</replace>
      <replace>:rejected-overall-mean</replace>
      <replace>XX</replace>
      <replace>rejected-score</replace>
      <replace>sent-ct</replace>
    </replaceStrings>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/resources/config.edn" />
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/config/dev/config.edn" />
        <option value="$PROJECT_DIR$/src/spamgen/genlist.clj" />
        <option value="$PROJECT_DIR$/test/spamgen/core_test.clj" />
        <option value="$PROJECT_DIR$/src/spamgen/core.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds">
    <option name="x" value="93" />
    <option name="y" value="68" />
    <option name="width" value="1531" />
    <option name="height" value="886" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="AndroidView" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
              <item name="dev" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="Scope" />
      <pane id="PackagesPane" />
      <pane id="Scratches" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="configurable.group.build" />
    <property name="cursive.last.file.extension./Users/kennethtilton/spamgen/src" value="clj" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/config/dev" />
    </key>
  </component>
  <component name="ReplState" timestamp="1521815741608">{:repl-history {:ide [], :local [{:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 10000))))\n  (pln :devtest-fini))&quot;, :offset 169, :ns &quot;spamgen.core-test&quot;} {:command &quot;(def env-hack\n  ;; todo persuade lein bin and config to work together\n  {\n   :smtp              [\&quot;1.2.3.4\&quot; \&quot;10.20.30.40\&quot; \&quot;100.200.101.201\&quot;\n                       \&quot;11.22.33.44\&quot; \&quot;111.112.113.114\&quot; \&quot;22.33.44.55\&quot;]\n   :worker-ct         1\n   :individual-max    0.3\n   :overall-mean-max  0.05\n   :last-n-mean-max   0.1\n   :last-n-span       100\n   :bulkmail-out-path \&quot;bulkmail\&quot;\n   })&quot;, :offset 376, :ns &quot;spamgen.core&quot;} {:command &quot;(defn span-mean-ok\n  \&quot;[w (writer) new-score (score of email being considered)]\n  Decide if this new score, if included, will violate running mean score\n  invariants specified in config.edn\&quot;\n\n  [w new-score]\n\n  (let [stats @(:stats w)\n        last-n-mean (:last-n-mean stats)\n        new-ct (min\n                 (:last-n-span env-hack)\n                 (inc (:em-ct stats)))\n        new-mean (+ last-n-mean\n                   (/ (- new-score last-n-mean) new-ct))]\n    (if (&lt;= new-mean (:last-n-mean-max env-hack))\n      (do\n        (swap! (:stats w) assoc :last-n-mean new-mean)\n        (pln :okspan new-ct new-mean (:last-n-mean-max env-hack))\n        true)\n      (do\n        (pln :failspan new-ct new-mean (:last-n-mean-max env-hack))\n        false))))&quot;, :offset 755, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 10))))\n  (pln :devtest-fini))&quot;, :offset 166, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn span-mean-ok\n  \&quot;[w (writer) new-score (score of email being considered)]\n  Decide if this new score, if included, will violate running mean score\n  invariants specified in config.edn\&quot;\n\n  [w new-score]\n\n  (let [stats @(:stats w)\n        last-n-mean (:last-n-mean stats)\n        new-ct (min\n                 (:last-n-span env-hack)\n                 (inc (:em-ct stats)))\n        new-mean (+ last-n-mean\n                   (/ (- new-score last-n-mean) new-ct))]\n    (if (&lt;= new-mean (:last-n-mean-max env-hack))\n      (do\n        (swap! (:stats w) assoc :last-n-mean new-mean)\n        (pln :okspan new-ct new-score new-mean (:last-n-mean-max env-hack))\n        true)\n      (do\n        (pln :failspan new-ct new-mean (:last-n-mean-max env-hack))\n        false))))&quot;, :offset 765, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 100))))\n  (pln :devtest-fini))&quot;, :offset 167, :ns &quot;spamgen.core-test&quot;} {:command &quot;(s/def ::spam-score\n  (s/double-in :min 0.08 :max 1))&quot;, :offset 53, :ns &quot;spamgen.genlist&quot;} {:command &quot;(s/def ::spam-score\n  (s/double-in :min 0.04 :max 1))&quot;, :offset 53, :ns &quot;spamgen.genlist&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 1000))))\n  (pln :devtest-fini))&quot;, :offset 168, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn span-mean-ok\n  \&quot;[w (writer) new-score (score of email being considered)]\n  Decide if this new score, if included, will violate running mean score\n  invariants specified in config.edn\&quot;\n\n  [w new-score]\n\n  (let [stats @(:stats w)\n        last-n-mean (:last-n-mean stats)\n        new-ct (min\n                 (:last-n-span env-hack)\n                 (inc (:em-ct stats)))\n        new-mean (+ last-n-mean\n                   (/ (- new-score last-n-mean) new-ct))]\n    (if (&lt;= new-mean (:last-n-mean-max env-hack))\n      (do\n        (swap! (:stats w) assoc :last-n-mean new-mean)\n        (pln :okspan new-ct new-mean new-score (:last-n-mean-max env-hack))\n        true)\n      (do\n        (pln :failspan new-ct new-mean (:last-n-mean-max env-hack))\n        false))))&quot;, :offset 765, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 40))))\n  (pln :devtest-fini))&quot;, :offset 166, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (pln :consider (:spam-score task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-abs] inc)\n      (pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            #_(pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:em-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          (pln :sending-to (:id w) (:spam-score task)\n            :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2222, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (pln :consider (:spam-score task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-abs] inc)\n      (pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:em-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          (pln :sending-to (:id w) (:spam-score task)\n            :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2209, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (pln :consider (:spam-score task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-abs] inc)\n      (pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (and (&gt; new-ct 100) ;; do not apply test until sample size useful\n          (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack)))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:em-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          (pln :sending-to (:id w) (:spam-score task)\n            :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2286, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (pln :consider (:spam-score task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-abs] inc)\n      (pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        ;; do not apply test until sample size useful,\n        ;; arbitrarily adopting :last-n parameter as useful\n        (and (&gt; new-ct (:last-n-span env-hack))\n          (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack)))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:em-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          (pln :sending-to (:id w) (:spam-score task)\n            :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2375, :ns &quot;spamgen.core&quot;} {:command &quot;(def env-hack\n  ;; todo persuade lein bin and config to work together\n  {\n   :smtp              [\&quot;1.2.3.4\&quot; \&quot;10.20.30.40\&quot; \&quot;100.200.101.201\&quot;\n                       \&quot;11.22.33.44\&quot; \&quot;111.112.113.114\&quot; \&quot;22.33.44.55\&quot;]\n   :worker-ct         6\n   :individual-max    0.3\n   :overall-mean-max  0.05\n   :last-n-mean-max   0.1\n   :last-n-span       100\n   :bulkmail-out-path \&quot;bulkmail\&quot;\n   })&quot;, :offset 376, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 4000))))\n  (pln :devtest-fini))&quot;, :offset 168, :ns &quot;spamgen.core-test&quot;} {:command &quot;(str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)&quot;, :offset 32, :ns &quot;spamgen.core-test&quot;} {:command &quot;(reduce (fn [p d]\n          (println [p d])\n          p)\n  [ 0 0]\n  (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;))&quot;, :offset 101, :ns &quot;spamgen.core-test&quot;} {:command &quot;(reduce (fn [[h v] d]\n          (println [p d])\n          (case d\n            \&quot;N\&quot; [h (inc v)]\n            \&quot;E\&quot; [(inc h) v]\n            \&quot;W\&quot; [(dec h) v]\n            \&quot;S\&quot; [h (dec v)]))\n  [ 0 0]\n  (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;))&quot;, :offset 224, :ns &quot;spamgen.core-test&quot;} {:command &quot;(reduce (fn [[h v] d]\n          (println [[h v] d])\n          (case d\n            \&quot;N\&quot; [h (inc v)]\n            \&quot;E\&quot; [(inc h) v]\n            \&quot;W\&quot; [(dec h) v]\n            \&quot;S\&quot; [h (dec v)]))\n  [ 0 0]\n  (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;))&quot;, :offset 228, :ns &quot;spamgen.core-test&quot;} {:command &quot;(println\n  (format ((fn [h v]\n             (format \&quot;%d by %d\&quot; h v))\n  (reduce (fn [[h v] d]\n          (println [[h v] d])\n          (case d\n            \&quot;N\&quot; [h (inc v)]\n            \&quot;E\&quot; [(inc h) v]\n            \&quot;W\&quot; [(dec h) v]\n            \&quot;S\&quot; [h (dec v)]))\n  [ 0 0]\n  (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))))&quot;, :offset 301, :ns &quot;spamgen.core-test&quot;} {:command &quot;(println\n  (format ((fn [[h v]]\n             (format \&quot;%d by %d\&quot; h v))\n  (reduce (fn [[h v] d]\n          (println [[h v] d])\n          (case d\n            \&quot;N\&quot; [h (inc v)]\n            \&quot;E\&quot; [(inc h) v]\n            \&quot;W\&quot; [(dec h) v]\n            \&quot;S\&quot; [h (dec v)]))\n  [ 0 0]\n  (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))))&quot;, :offset 303, :ns &quot;spamgen.core-test&quot;} {:command &quot;(println\n  (format ((fn [[h v]]\n             (format \&quot;%d by %d\&quot; h v))\n  (reduce (fn [[h v] d]\n          (println [(list h v) d])\n          (case d\n            \&quot;N\&quot; [h (inc v)]\n            \&quot;E\&quot; [(inc h) v]\n            \&quot;W\&quot; [(dec h) v]\n            \&quot;S\&quot; [h (dec v)]))\n  [ 0 0]\n  (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))))&quot;, :offset 308, :ns &quot;spamgen.core-test&quot;} {:command &quot;(println\n  (format ((fn [[h v]]\n             (println (list h v))\n             (println (format \&quot;Distance %.3f\&quot;\n                        (Math/sqrt (+ (* h h)(* v v))))))\n            (reduce (fn [[h v] d]\n                      (println [(list h v) d])\n                      (case d\n                        \&quot;N\&quot; [h (inc v)]\n                        \&quot;E\&quot; [(inc h) v]\n                        \&quot;W\&quot; [(dec h) v]\n                        \&quot;S\&quot; [h (dec v)]))\n              [0 0]\n              (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))))&quot;, :offset 513, :ns &quot;spamgen.core-test&quot;} {:command &quot;((fn [[h v]]\n   (println (list h v))\n   (println (format \&quot;Distance %.3f\&quot;\n              (Math/sqrt (+ (* h h)(* v v))))))\n  (reduce (fn [[h v] d]\n            (println [(list h v) d])\n            (case d\n              \&quot;N\&quot; [h (inc v)]\n              \&quot;E\&quot; [(inc h) v]\n              \&quot;W\&quot; [(dec h) v]\n              \&quot;S\&quot; [h (dec v)]))\n    [0 0]\n    (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))&quot;, :offset 372, :ns &quot;spamgen.core-test&quot;} {:command &quot;((fn [[h v]]\n   (println (list h v))\n   (println (format \&quot;Distance %.3f\&quot;\n              (Math/sqrt (+ (* h h)(* v v))))))\n  (reduce (fn [[h v] d]\n            (println [(list h v) d])\n            (case d\n              \&quot;N\&quot; [0 1]\n              \&quot;E\&quot; [ 10]\n              \&quot;W\&quot; [(dec h) v]\n              \&quot;S\&quot; [h (dec v)]))\n    [0 0]\n    (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))&quot;, :offset 360, :ns &quot;spamgen.core-test&quot;} {:command &quot;(map + [1 2] [3 4])&quot;, :offset 19, :ns &quot;spamgen.core-test&quot;} {:command &quot;((fn [[h v]]\n   (println (list h v))\n   (println (format \&quot;Distance %.3f\&quot;\n              (Math/sqrt (+ (* h h)(* v v))))))\n  (reduce (fn [[h v] d]\n            (println [(list h v) d])\n            (map + [h v]\n            (case d\n              \&quot;N\&quot; [0 1]\n              \&quot;E\&quot; [1 0]\n              \&quot;W\&quot; [-1 0]\n              \&quot;S\&quot; [0 -1])))\n    [0 0]\n    (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))&quot;, :offset 376, :ns &quot;spamgen.core-test&quot;} {:command &quot;((fn [[h v]]\n   (println (list h v))\n   (println (format \&quot;Distance %.3f\&quot;\n              (Math/sqrt (+ (* h h) (* v v))))))\n  (reduce (fn [p d]\n            (println [p d])\n            (map + [h v]\n              (case d\n                \&quot;N\&quot; [0 1]\n                \&quot;E\&quot; [1 0]\n                \&quot;W\&quot; [-1 0]\n                \&quot;S\&quot; [0 -1])))\n    [0 0]\n    (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))&quot;, :offset 374, :ns &quot;spamgen.core-test&quot;} {:command &quot;((fn [[h v]]\n   (println (list h v))\n   (println (format \&quot;Distance %.3f\&quot;\n              (Math/sqrt (+ (* h h) (* v v))))))\n  (reduce (fn [p d]\n            (println [p d])\n            (map + p\n              (case d\n                \&quot;N\&quot; [0 1]\n                \&quot;E\&quot; [1 0]\n                \&quot;W\&quot; [-1 0]\n                \&quot;S\&quot; [0 -1])))\n    [0 0]\n    (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))&quot;, :offset 370, :ns &quot;spamgen.core-test&quot;} {:command &quot;((fn [[h v]]\n   (println (list h v))\n   (println (format \&quot;Distance %.3f\&quot;\n              (Math/sqrt (+ (* h h) (* v v))))))\n  (reduce (fn [p d]\n            (println p)\n            (map + p\n              (case d\n                \&quot;N\&quot; [0 1]\n                \&quot;E\&quot; [1 0]\n                \&quot;W\&quot; [-1 0]\n                \&quot;S\&quot; [0 -1])))\n    [0 0]\n    (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))&quot;, :offset 366, :ns &quot;spamgen.core-test&quot;} {:command &quot;(map * [2 3][2 3])&quot;, :offset 18, :ns &quot;spamgen.core-test&quot;} {:command &quot;((fn [p]\n   (println p)\n   (println (format \&quot;Distance %.3f\&quot;\n              (Math/sqrt (map + (map * p p))))))\n  (reduce (fn [p d]\n            (println p)\n            (map + p\n              (case d\n                \&quot;N\&quot; [0 1]\n                \&quot;E\&quot; [1 0]\n                \&quot;W\&quot; [-1 0]\n                \&quot;S\&quot; [0 -1])))\n    [0 0]\n    (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))&quot;, :offset 353, :ns &quot;spamgen.core-test&quot;} {:command &quot;((fn [p]\n   (println p)\n   (println (format \&quot;Distance %.3f\&quot;\n              (Math/sqrt (apply + (map * p p))))))\n  (reduce (fn [p d]\n            (println p)\n            (map + p\n              (case d\n                \&quot;N\&quot; [0 1]\n                \&quot;E\&quot; [1 0]\n                \&quot;W\&quot; [-1 0]\n                \&quot;S\&quot; [0 -1])))\n    [0 0]\n    (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))&quot;, :offset 355, :ns &quot;spamgen.core-test&quot;} {:command &quot;(^ 3 2)&quot;, :offset 7, :ns &quot;spamgen.core-test&quot;} {:command &quot;(** 3 2)&quot;, :offset 8, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [moves {\&quot;N\&quot; [0 1]\n             \&quot;E\&quot; [1 0]\n             \&quot;W\&quot; [-1 0]\n             \&quot;S\&quot; [0 -1]}]\n      (#{\&quot;N\&quot;} moves))&quot;, :offset 117, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [moves {\&quot;N\&quot; [0 1]\n             \&quot;E\&quot; [1 0]\n             \&quot;W\&quot; [-1 0]\n             \&quot;S\&quot; [0 -1]}]\n      (get moves \&quot;N\&quot;))&quot;, :offset 118, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [moves {\&quot;N\&quot; [0 1]\n             \&quot;E\&quot; [1 0]\n             \&quot;W\&quot; [-1 0]\n             \&quot;S\&quot; [0 -1]}]\n  (map #(get moves %)\n    (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)))&quot;, :offset 156, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [moves {\&quot;N\&quot; [0 1]\n             \&quot;E\&quot; [1 0]\n             \&quot;W\&quot; [-1 0]\n             \&quot;S\&quot; [0 -1]}]\n  (reduce (fn [p m]\n            (println p)\n            (map + p m))\n    (map #(get moves %)\n      (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;))))&quot;, :offset 230, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt; \&quot;N E E S S W S\&quot;\n  (str/split #\&quot; \&quot;))&quot;, :offset 39, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt; \&quot;N E E S S W S\&quot;\n  (str/split #\&quot; \&quot;)\n  #(map #(get % {\&quot;N\&quot; [0 1]\n                 \&quot;E\&quot; [1 0]\n                 \&quot;W\&quot; [-1 0]\n                 \&quot;S\&quot; [0 -1]})))&quot;, :offset 152, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt; \&quot;N E E S S W S\&quot;\n  (str/split #\&quot; \&quot;)\n  (fn [ms]\n    (map #(get % {\&quot;N\&quot; [0 1]\n                 \&quot;E\&quot; [1 0]\n                 \&quot;W\&quot; [-1 0]\n                 \&quot;S\&quot; [0 -1]}) ms)))&quot;, :offset 168, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt; \&quot;N E E S S W S\&quot;\n  (str/split #\&quot; \&quot;)\n  println)&quot;, :offset 49, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt; \&quot;N E E S S W S\&quot;\n  (str/split #\&quot; \&quot;)\n  (fn [ms]\n    (map (fn [m] (get m {\&quot;N\&quot; [0 1]\n                                        \&quot;E\&quot; [1 0]\n                                        \&quot;W\&quot; [-1 0]\n                                        \&quot;S\&quot; [0 -1]})))))&quot;, :offset 242, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt; \&quot;N E E S S W S\&quot;\n  (str/split #\&quot; \&quot;)\n  (fn [ms]\n    (map (fn [m] (get m {\&quot;N\&quot; [0 1]\n                                        \&quot;E\&quot; [1 0]\n                                        \&quot;W\&quot; [-1 0]\n                                        \&quot;S\&quot; [0 -1]})) ms)))&quot;, :offset 245, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; [:foo :bar] v\n  (map name v)\n  (first v)\n  (.substring v 1))&quot;, :offset 66, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; x\n  (str/split x #\&quot; \&quot;)\n  (map #(get % {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]})))&quot;, :offset 106, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; x\n  (str/split x #\&quot; \&quot;))&quot;, :offset 45, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; x\n  (str/split x #\&quot; \&quot;)\n  (map #(get % {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]}) x))&quot;, :offset 108, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; x\n  (str/split x #\&quot; \&quot;)\n  (map #(get \&quot;N\&quot; {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]}) x))&quot;, :offset 110, :ns &quot;spamgen.core-test&quot;} {:command &quot;(get \&quot;N\&quot; {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]})&quot;, :offset 53, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; x\n  (str/split x #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %) x))&quot;, :offset 108, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; x\n  (str/split x #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %) x)\n  (reduce (fn [p m]\n            (println p)\n            (map + p m)) x))&quot;, :offset 180, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; x\n  (str/split x #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %) x)\n  (reduce (fn [p m]\n            (println p)\n            (map + p m)) x)\n  ((fn [[h v]]\n    (println (list h v))\n    (println (format \&quot;Distance %.3f\&quot;\n               (Math/sqrt (+ (* h h) (* v v)))))) x))&quot;, :offset 310, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; x\n  (str/split x #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %) x)\n  (reduce (fn [p m] (println p) (map + p m)) x)\n  ((fn [[h v]]\n    (println (list h v))\n    (println (format \&quot;Distance %.3f\&quot;\n               (Math/sqrt (+ (* h h) (* v v)))))) x))&quot;, :offset 286, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; BAM\n  (str/split BAM #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %) BAM)\n  (reduce (fn [p m] (println p) (map + p m)) BAM)\n  ((fn [[h v]]\n    (println (list h v))\n    (println (format \&quot;Distance %.3f\&quot;\n               (Math/sqrt (+ (* h h) (* v v)))))) BAM))&quot;, :offset 296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; XXX\n  (str/split XXX #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %) XXX)\n  (reduce (fn [p m] (println p) (map + p m)) [0 0] XXX)\n  ((fn [[h v]]\n    (println (list h v))\n    (println (format \&quot;Distance %.3f\&quot;\n               (Math/sqrt (+ (* h h) (* v v)))))) XXX))&quot;, :offset 302, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; XX\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %)\n    (str/split XX #\&quot; \&quot;))\n  (reduce (fn [p m] (println p) (map + p m)) [0 0] XX)\n  ((fn [[h v]]\n    (println (list h v))\n    (println (format \&quot;Distance %.3f\&quot;\n               (Math/sqrt (+ (* h h) (* v v)))))) XX))&quot;, :offset 296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [p [1 -2]]\n  (map * p p))&quot;, :offset 30, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [p [1 -2]]\n  (map + (map * p p)))&quot;, :offset 38, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [p [1 -2]]\n  (apply + (map * p p)))&quot;, :offset 40, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; XX\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %)\n    (str/split XX #\&quot; \&quot;))\n  (reduce (fn [p m] (println p) (map + p m)) [0 0] XX)\n  ((fn [p]\n     (println p)\n     (println (format \&quot;Distance %.3f\&quot;\n                (Math/sqrt (apply + (map * p p)))))) XX))&quot;, :offset 288, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; XX\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %)\n    (str/split XX #\&quot; \&quot;))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0] XX)\n  ((fn [p]\n     (println p)\n     (println (format \&quot;Distance %.3f\&quot;\n                (Math/sqrt (apply + (map * p p)))))) XX))&quot;, :offset 303, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; XX\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %)\n    (str/split XX #\&quot; \&quot;))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0] XX)\n  ((fn [posn]\n     (println posn)\n     (println (format \&quot;Distance %.3f\&quot;\n                (Math/sqrt (apply + (map * posn posn)))))) XX))&quot;, :offset 315, :ns &quot;spamgen.core-test&quot;} {:command &quot;(as-&gt; \&quot;N E E S S W S\&quot; XX\n  (str/split XX #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %) XX)\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0] XX)\n  ((fn [posn]\n     (println posn)\n     (println (format \&quot;Distance %.3f\&quot;\n                (Math/sqrt (apply + (map * posn posn)))))) XX))&quot;, :offset 316, :ns &quot;spamgen.core-test&quot;} {:command &quot;(--&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println posn)\n     (println (format \&quot;Distance %.3f\&quot;\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 298, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println posn)\n     (println (format \&quot;Distance %.3f\&quot;\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 298, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println (format \&quot;Crow has landed at %, distance %.3f\&quot;\n                posn\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 321, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println (format \&quot;Crow has landed at %a, distance %.3f\&quot;\n                posn\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 322, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println (format \&quot;Crow has landed at %s, distance %.3f\&quot;\n                posn\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 322, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println (format \&quot;Crow has landed at %s, distance %.3f\&quot;\n                (str posn)\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 328, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println (format \&quot;Crow has landed at %a, distance %.3f\&quot;\n                (str posn)\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 328, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println (format \&quot;Crow has landed at %v, distance %.3f\&quot;\n                (str posn)\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 328, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println (format \&quot;Crow has landed at %s, distance %.3f\&quot;\n                (doall posn)\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 330, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println (format \&quot;Crow has landed at %s, distance %.3f\&quot;\n                (map str posn)\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 332, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println (format \&quot;Crow has landed at %s, distance %.3f\&quot;\n                (map % posn)\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 330, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [posn]\n     (println (format \&quot;Crow has landed at %s, distance %.3f\&quot;\n                (pr-str posn)\n                (Math/sqrt (apply + (map * posn posn))))))))&quot;, :offset 331, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [[lat lon]]\n     (println (format \&quot;Crow has landed at (%d, %d), distance %.3f\&quot;\n                lat lon\n                (Math/sqrt + (* lat lat)(* lon lon)))))))&quot;, :offset 333, :ns &quot;spamgen.core-test&quot;} {:command &quot;(-&gt;&gt; (str/split \&quot;N E E S S W S\&quot; #\&quot; \&quot;)\n  (map #(get {\&quot;N\&quot; [0 1] \&quot;E\&quot; [1 0] \&quot;W\&quot; [-1 0] \&quot;S\&quot; [0 -1]} %))\n  (reduce (fn [posn move] (println posn) (map + posn move)) [0 0])\n  ((fn [[lat lon]]\n     (println (format \&quot;Crow has landed at (%d, %d), distance %.3f\&quot;\n                lat lon\n                (Math/sqrt (+ (* lat lat)(* lon lon))))))))&quot;, :offset 335, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 4000))))\n  (pln :devtest-fini))&quot;, :offset 167, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (println :multiprocessing)\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct              0\n                                          :last-n-mean        0\n                                          :spam-score-sum     0\n                                          :rejected-abs       0\n                                          :rejected-dup-addr  0\n                                          :rejected-overall-mean   0\n                                          :rejected-span-mean 0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (doseq [w workers]\n      (pln)\n      (pln (format \&quot;worker %d:\&quot; (:id w)))\n      (pp/pprint @(:stats w))\n      (pln))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2517, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 40000))))\n  (pln :devtest-fini))&quot;, :offset 168, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 400000))))\n  (pln :devtest-fini))&quot;, :offset 169, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-records-duped-test-gen\n  ([] (repeatedly\n        #(gen/generate (s/gen ::email-record-duped))))\n  ([n]\n   (if (nil? n)\n     (email-records-duped-test-gen)\n     (take n (email-records-duped-test-gen)))))&quot;, :offset 214, :ns &quot;spamgen.genlist&quot;} {:command &quot;(email-records-duped-test-gen 1)&quot;, :offset 32, :ns &quot;spamgen.genlist&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (println :multiprocessing)\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct              0\n                                          :last-n-mean        0\n                                          :spam-score-sum     0\n                                          :rejected-abs       0\n                                          :rejected-dup-addr  0\n                                          :rejected-overall-mean   0\n                                          :rejected-span-mean 0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (doseq [w workers]\n      (pln)\n      (pln (format \&quot;worker %d:\&quot; (:id w)))\n      (pp/pprint @(:stats w))\n      (pln))\n\n    (pln :summary)\n    (pln (apply merge-with +\n           (map #(select-keys @(:stats %) [:em-ct]) workers)))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2629, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (println :multiprocessing)\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct              0\n                                          :last-n-mean        0\n                                          :spam-score-sum     0\n                                          :rejected-abs       0\n                                          :rejected-dup-addr  0\n                                          :rejected-overall-mean   0\n                                          :rejected-span-mean 0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (doseq [w workers]\n      (pln)\n      (pln (format \&quot;worker %d:\&quot; (:id w)))\n      (pp/pprint @(:stats w))\n      (pln))\n\n    (pln :summary)\n    (pln (apply merge-with +\n           (map #(select-keys @(:stats %)\n                   [:em-ct :rejected-abs :rejected-dup-addr\n                    :rejected-overall-mean\n                    :rejected-span-mean])\n             workers)))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2777, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (println :multiprocessing)\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct              0\n                                          :last-n-mean        0\n                                          :spam-score-sum     0\n                                          :rejected-abs       0\n                                          :rejected-dup-addr  0\n                                          :rejected-overall-mean   0\n                                          :rejected-span-mean 0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (doseq [w workers]\n      (pln)\n      (pln (format \&quot;worker %d:\&quot; (:id w)))\n      (pp/pprint @(:stats w))\n      (pln))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n           (map #(select-keys @(:stats %)\n                   [:em-ct :rejected-abs :rejected-dup-addr\n                    :rejected-overall-mean\n                    :rejected-span-mean])\n             workers)))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2783, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (println :multiprocessing)\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan)\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct              0\n                                          :last-n-mean        0\n                                          :spam-score-sum     0\n                                          :rejected-abs       0\n                                          :rejected-dup-addr  0\n                                          :rejected-overall-mean   0\n                                          :rejected-span-mean 0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (doseq [w workers]\n      (pln)\n      (pln (format \&quot;worker %d:\&quot; (:id w)))\n      (pp/pprint @(:stats w))\n      (pln))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n           (map #(select-keys @(:stats %)\n                   [:em-ct :rejected-abs :rejected-dup-addr\n                    :rejected-overall-mean\n                    :rejected-span-mean])\n             workers)))\n    \n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2797, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-abs] inc)\n      #_ (pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        ;; do not apply test until sample size useful,\n        ;; arbitrarily adopting :last-n parameter as useful\n        (and (&gt; new-ct (:last-n-span env-hack))\n          (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack)))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            #_ (pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            #_ (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:em-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_ (pln :sending-to (:id w) (:spam-score task)\n            :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2408, :ns &quot;spamgen.core&quot;} {:command &quot;(def spamgen-cli\n  [[\&quot;-t\&quot; \&quot;--test TESTCOUNT\&quot; \&quot;Number of test email records to process ignoring file arg\&quot;\n    :id :test-count\n    :default 100\n    ;; todo handle inputs like 100k\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1)\&quot;]]\n   [\&quot;-v\&quot; \&quot;--verbose\&quot;]\n  \n   [\&quot;-h\&quot; \&quot;--help\&quot;]])&quot;, :offset 326, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 30000)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 182, :ns &quot;spamgen.core-test&quot;} {:command &quot;(s/def ::spam-score\n  (s/double-in :min 0.0 :max 1))&quot;, :offset 52, :ns &quot;spamgen.genlist&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 100)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 180, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        ;; do not apply test until sample size useful,\n        ;; arbitrarily adopting :last-n parameter as useful\n        (and (&gt; new-ct (:last-n-span env-hack))\n          (&gt; (/ new-sum new-ct)\n            (:overall-mean-max env-hack)))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            #_(pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            #_(pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2414, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 1000)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 181, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  ;;(pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        ;; do not apply test until sample size useful,\n        ;; arbitrarily adopting :last-n parameter as useful\n        (and (&gt; new-ct (:last-n-span env-hack))\n          (&gt; (/ new-sum new-ct)\n            (:overall-mean-max env-hack)))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            #_(pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            #_(pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct          new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2416, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 10000)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 182, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 50000)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 182, :ns &quot;spamgen.core-test&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.main">
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
    <configuration name="main" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="1" />
      <module name="spamgen" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="" />
      <created>1521628166875</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1521628166875</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="93" y="68" width="1531" height="886" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.3435663" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.13912475" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
    </layout>
    <layout-to-restore>
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.3435663" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.13912475" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
    </layout-to-restore>
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <option name="time" value="1" />
    </breakpoint-manager>
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="153">
          <caret line="9" column="0" lean-forward="false" selection-start-line="9" selection-start-column="0" selection-end-line="9" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="17">
          <caret line="1" column="0" lean-forward="true" selection-start-line="1" selection-start-column="0" selection-end-line="1" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="18" lean-forward="true" selection-start-line="7" selection-start-column="18" selection-end-line="7" selection-end-column="18" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="249">
          <caret line="3207" column="10" lean-forward="false" selection-start-line="3207" selection-start-column="10" selection-end-line="3207" selection-end-column="10" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="357">
          <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/config/dev/config.edn">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="13" lean-forward="false" selection-start-line="7" selection-start-column="1" selection-end-line="7" selection-end-column="13" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="259">
          <caret line="36" column="16" lean-forward="false" selection-start-line="36" selection-start-column="16" selection-end-line="36" selection-end-column="16" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="272">
          <caret line="16" column="20" lean-forward="true" selection-start-line="16" selection-start-column="20" selection-end-line="16" selection-end-column="20" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="273">
          <caret line="190" column="11" lean-forward="false" selection-start-line="190" selection-start-column="11" selection-end-line="190" selection-end-column="11" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>