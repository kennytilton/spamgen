<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="">
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/spamgen" afterPath="$PROJECT_DIR$/spamgen" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/src/spamgen/core.clj" afterPath="$PROJECT_DIR$/src/spamgen/core.clj" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="project.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="357">
              <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="config.edn" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/config/dev/config.edn">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="170">
              <caret line="10" column="2" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="10" selection-end-column="2" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core_test.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="238">
              <caret line="14" column="16" lean-forward="false" selection-start-line="14" selection-start-column="16" selection-end-line="14" selection-end-column="16" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.clj" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="446">
              <caret line="72" column="70" lean-forward="true" selection-start-line="72" selection-start-column="70" selection-end-line="72" selection-end-column="70" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="genlist.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="452">
              <caret line="47" column="41" lean-forward="false" selection-start-line="47" selection-start-column="41" selection-end-line="47" selection-end-column="41" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>test-email-records</find>
      <find>println</find>
      <find>:sent</find>
      <find>env</find>
    </findStrings>
    <replaceStrings>
      <replace>em-addrs-hit</replace>
      <replace>:addrs-hit</replace>
      <replace>*env*</replace>
    </replaceStrings>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/resources/config.edn" />
        <option value="$PROJECT_DIR$/src/spamgen/genlist.clj" />
        <option value="$PROJECT_DIR$/config/dev/config.edn" />
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/test/spamgen/core_test.clj" />
        <option value="$PROJECT_DIR$/src/spamgen/core.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds">
    <option name="x" value="93" />
    <option name="y" value="67" />
    <option name="width" value="1531" />
    <option name="height" value="886" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="AndroidView" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
              <item name="dev" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="Scope" />
      <pane id="PackagesPane" />
      <pane id="Scratches" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="configurable.group.build" />
    <property name="cursive.last.file.extension./Users/kennethtilton/spamgen/src" value="clj" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/config/dev" />
    </key>
  </component>
  <component name="ReplState" timestamp="1521747203358">{:repl-history {:ide [], :local [{:command &quot;(defn emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_ (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:max-overall-spam-score env)))\n\n        ;;(not (running-mean-ok? w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        ;;(do (pln :running-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (when-not (get @(:addrs-hit w) addr)\n                    (alter (:addrs-hit w) conj addr)\n                    true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          #_(pln :sending-to (:id w) (:email-address task))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 1788, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile ; Profile any `p` forms called during body execution\n    {} ; Profiling options; we'll use the defaults for now\n    #_ (p :send-100 (email-batch-to-sendfiles\n                (email-records-test-gen 100)))\n    #_ (p :send-1000 (email-batch-to-sendfiles\n                    (email-records-test-gen 1000 )))\n    #_ (p :send-10000 (email-batch-to-sendfiles\n                    (email-records-test-gen 10000)))\n    (p :send-100000 (email-batch-to-sendfiles\n                     (email-records-test-gen 100000)))))&quot;, :offset 536, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_ (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:max-overall-spam-score env)))\n\n        ;;(not (running-mean-ok? w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        ;;(do (pln :running-mean-bad (:spam-score task)))\n\n        :default\n        (when true #_ (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (when-not (get @(:addrs-hit w) addr)\n                    (alter (:addrs-hit w) conj addr)\n                    true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          #_(pln :sending-to (:id w) (:email-address task))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 1796, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-email-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2123, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile ; Profile any `p` forms called during body execution\n    {} ; Profiling options; we'll use the defaults for now\n    #_ (p :send-100 (email-batch-to-sendfiles\n                (email-records-test-gen 100)))\n    #_ (p :send-1000 (email-batch-to-sendfiles\n                    (email-records-test-gen 1000 )))\n    #_ (p :send-10000 (email-batch-to-sendfiles\n                    (email-records-test-gen 10000)))\n    (p :send-100000 (email-batch-to-sendfiles\n                     (email-records-test-gen 50000)))))&quot;, :offset 535, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-email-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2122, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (p :consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2136, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2142, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (p :spit-init\n      (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)})))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2163, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile                                                  ; Profile any `p` forms called during body execution\n    {:dynamic? true}                                                      ; Profiling options; we'll use the defaults for now\n    #_(p :send-100 (email-batch-to-sendfiles\n                     (email-records-test-gen 100)))\n    #_(p :send-1000 (email-batch-to-sendfiles\n                      (email-records-test-gen 1000)))\n    #_(p :send-10000 (email-batch-to-sendfiles\n                       (email-records-test-gen 10000)))\n    (p ::send-100000\n      (email-batch-to-sendfiles\n        (email-records-test-gen 5000)))))&quot;, :offset 650, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile                                                  ; Profile any `p` forms called during body execution\n    {:dynamic? true}                                                      ; Profiling options; we'll use the defaults for now\n    #_(p :send-100 (email-batch-to-sendfiles\n                     (email-records-test-gen 100)))\n    #_(p :send-1000 (email-batch-to-sendfiles\n                      (email-records-test-gen 1000)))\n    #_(p :send-10000 (email-batch-to-sendfiles\n                       (email-records-test-gen 10000)))\n    (p ::send-100000\n      (email-batch-to-sendfiles\n        (email-records-test-gen 50000)))))&quot;, :offset 651, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (p :spit-init\n      (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)})))\n\n    (p :feed-workers\n      (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream)))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2187, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          (partition-all 100 email-stream))))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2191, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile                                                  ; Profile any `p` forms called during body execution\n    {:dynamic? true}                                                      ; Profiling options; we'll use the defaults for now\n    #_(p :send-100 (email-batch-to-sendfiles\n                     (email-records-test-gen 100)))\n    #_(p :send-1000 (email-batch-to-sendfiles\n                      (email-records-test-gen 1000)))\n    #_(p :send-10000 (email-batch-to-sendfiles\n                       (email-records-test-gen 10000)))\n    (p ::send-100000\n      (email-batch-to-sendfiles\n        (email-records-test-gen 500000)))))&quot;, :offset 652, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em100.txt\&quot; (email-records-test-gen 100))&quot;, :offset 57, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em100x.txt\&quot; (doall (email-records-test-gen 100)))&quot;, :offset 66, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em100.txt\&quot; (doall (email-records-test-gen 100)))&quot;, :offset 65, :ns &quot;spamgen.core-test&quot;} {:command &quot;(count (slurp \&quot;bulkinput/em100.txt\&quot;))&quot;, :offset 37, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn edn-load [path]\n   (with-open [in (java.io.PushbackReader. (clojure.java.io/reader path))]\n     (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n       (take-while (partial not= :fini) edn-seq))))&quot;, :offset 216, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em10.txt\&quot; (vec (email-records-test-gen 10)))&quot;, :offset 61, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn edn-load [path]\n   (with-open [in (java.io.PushbackReader. (clojure.java.io/reader path))]\n     (edn/read in)\n     #_\n     (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n       (take-while (partial not= :fini) edn-seq))))&quot;, :offset 243, :ns &quot;spamgen.core-test&quot;} {:command &quot;(edn-load \&quot;bulkinput/em100.txt\&quot;)&quot;, :offset 32, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em100.txt\&quot; (vec (email-records-test-gen 100)))&quot;, :offset 63, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em1000.txt\&quot; (vec (email-records-test-gen 1000)))&quot;, :offset 65, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em10000.txt\&quot; (vec (email-records-test-gen 10000)))&quot;, :offset 67, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em100000.txt\&quot; (vec (email-records-test-gen 100000)))&quot;, :offset 69, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn bulk-input-build [prefix em-count]\n  (let [bf (str \&quot;bulkinput/\&quot; prefix \&quot;-\&quot; em-count \&quot;.edn\&quot;)]\n    (spit bf {:build-date (.toString (java.util.Date.))\n              :count em-count})\n    (doseq [em (email-records-test-gen em-count)]\n      (spit bf em :append true))))&quot;, :offset 271, :ns &quot;spamgen.core-test&quot;} {:command &quot;(bulk-input-build \&quot;emf\&quot; 10)&quot;, :offset 27, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn bulk-input-sequence [path]\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader path))]\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (take-while (partial not= :fini) edn-seq))))&quot;, :offset 224, :ns &quot;spamgen.core&quot;} {:command &quot;(first (bulk-input-sequence \&quot;emf-10.edn\&quot;))&quot;, :offset 42, :ns &quot;spamgen.core&quot;} {:command &quot;(first (bulk-input-sequence \&quot;bulkinput/emf-10.edn\&quot;))&quot;, :offset 52, :ns &quot;spamgen.core&quot;} {:command &quot;(defn bulk-input-sequence [path handler]\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader path))]\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (dorun (map handler (take-while (partial not= :fini) edn-seq))))))&quot;, :offset 254, :ns &quot;spamgen.core&quot;} {:command &quot;(bulk-input-sequence \&quot;bulkinput/emf-10.edn\&quot; println)&quot;, :offset 52, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest infile-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader path))]\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (email-batch-to-sendfiles edn-seq))))&quot;, :offset 204, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest infile-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-10.edn\&quot;))]\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (email-batch-to-sendfiles edn-seq))))&quot;, :offset 222, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest infile-edn\n  (pln :startedn)\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-10.edn\&quot;))]\n    (pln :ednin in)\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (pln :eseq edn-seq)\n      (email-batch-to-sendfiles edn-seq))))&quot;, :offset 286, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n  (pln :stream! email-stream (first email-stream))\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2222, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n  (pln :stream! email-stream (first email-stream))\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (pln :do-em em-rec)\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2257, :ns &quot;spamgen.core&quot;} {:command &quot;(defn -main [&amp; args]\n  ;; #_ ;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what :uncaught-exception\n                        :exception ex\n                        :where (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n\n  (let [input (parse-opts args times-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [width spacing test help]} options\n        built-ins (let [known (vec (rest (file-seq\n                                           (clojure.java.io/file \&quot;./resources\&quot;))))]\n                    (when (&gt; test (count known))\n                      (println (format \&quot;\\nWarning: only %d test files exist in ./resources\\n\\n\&quot;\n                                 (count known))))\n                    (map #(.getPath %)\n                      (subvec known 0 (min test (count known)))))\n        filepaths (concat arguments built-ins)]\n\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    concurtimes options* files*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      :default (do\n                 #_ (email-batch-to-sendfiles &lt;tbd&gt;)\n                 (pln :fnyi))\n      ))\n\n  ;; WARNING: comment this out for use with REPL\n  ;;(shutdown-agents)\n  )&quot;, :offset 1418, :ns &quot;spamgen.core&quot;} {:command &quot;(defn -main [&amp; args]\n  ;; #_ ;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what :uncaught-exception\n                        :exception ex\n                        :where (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n\n  (pln :main args)\n  (let [input (parse-opts args spamgen-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [width spacing test help]} options\n        built-ins (let [known (vec (rest (file-seq\n                                           (clojure.java.io/file \&quot;./resources\&quot;))))]\n                    (when (&gt; test (count known))\n                      (println (format \&quot;\\nWarning: only %d test files exist in ./resources\\n\\n\&quot;\n                                 (count known))))\n                    (map #(.getPath %)\n                      (subvec known 0 (min test (count known)))))\n        filepaths (concat arguments built-ins)]\n\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    concurtimes options* files*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      :default (do\n                 #_ (email-batch-to-sendfiles &lt;tbd&gt;)\n                 (println :fnyi))\n      ))\n\n  ;; WARNING: comment this out for use with REPL\n  ;;(shutdown-agents)\n  )&quot;, :offset 1443, :ns &quot;spamgen.core&quot;} {:command &quot;(def spamgen-cli\n  [[\&quot;-w\&quot; \&quot;--width PAGEWIDTH\&quot; \&quot;Page width in number of characters\&quot;\n    :default 80\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 2 % 256) \&quot;Must be a number from 2 to 256\&quot;]]\n\n   ;; A boolean option defaulting to nil\n   [\&quot;-h\&quot; \&quot;--help\&quot;]]\n  )&quot;, :offset 264, :ns &quot;spamgen.core&quot;} {:command &quot;(-main)&quot;, :offset 7, :ns &quot;spamgen.core&quot;} {:command &quot;(-main -h)&quot;, :offset 10, :ns &quot;spamgen.core&quot;} {:command &quot;(defn -main [&amp; args]\n  ;; #_ ;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what :uncaught-exception\n                        :exception ex\n                        :where (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n\n  (pln :main args spamgen-cli)\n  (pln :pops (cli/parse-opts args spamgen-cli))\n  (let [input (cli/parse-opts args spamgen-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [width spacing test help]} options]\n\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    concurtimes options* files*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      :default (do\n                 #_ (email-batch-to-sendfiles &lt;tbd&gt;)\n                 (println :fnyi))\n      ))\n\n  ;; WARNING: comment this out for use with REPL\n  ;;(shutdown-agents)\n  )&quot;, :offset 1025, :ns &quot;spamgen.core&quot;} {:command &quot;(defn -main [&amp; args]\n  ;; #_ ;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what :uncaught-exception\n                        :exception ex\n                        :where (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n\n  (pln :main args spamgen-cli)\n  (pln :pops (cli/parse-opts args spamgen-cli))\n  (let [input (cli/parse-opts args spamgen-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [width spacing test help]} options]\n\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    spamgen &lt;input-edn&gt; options*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      :default (do\n                 #_ (email-batch-to-sendfiles &lt;tbd&gt;)\n                 (println :fnyi))\n      ))\n\n  ;; WARNING: comment this out for use with REPL\n  ;;(shutdown-agents)\n  )&quot;, :offset 1026, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;abc\&quot; \&quot;-h\&quot;)&quot;, :offset 18, :ns &quot;spamgen.core&quot;} {:command &quot;(defn -main [&amp; args]\n  ;; #_ ;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what :uncaught-exception\n                        :exception ex\n                        :where (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n\n  (pln :main args )\n  \n  (let [input (cli/parse-opts args spamgen-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [width spacing test help]} options]\n\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    spamgen &lt;input-edn&gt; options*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      :default (do\n                 #_ (email-batch-to-sendfiles &lt;tbd&gt;)\n                 (println :fnyi))\n      ))\n\n  ;; WARNING: comment this out for use with REPL\n  ;;(shutdown-agents)\n  )&quot;, :offset 970, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot; \&quot;-h\&quot;)&quot;, :offset 35, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot; \&quot;-j\&quot;)&quot;, :offset 35, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot; \&quot;-j\&quot; \&quot;-p\&quot;)&quot;, :offset 40, :ns &quot;spamgen.core&quot;} {:command &quot;(def spamgen-cli\n  [[\&quot;-t\&quot; \&quot;--test TESTCOUNT\&quot; \&quot;Number of test email records to process ignoring file arg\&quot;\n    :default 100\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1)\&quot;]]\n\n   ;; A boolean option defaulting to nil\n   [\&quot;-h\&quot; \&quot;--help\&quot;]]\n  )&quot;, :offset 290, :ns &quot;spamgen.core&quot;} {:command &quot;(defn -main [&amp; args]\n  ;; #_ ;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what :uncaught-exception\n                        :exception ex\n                        :where (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n\n  (pln :main args )\n  \n  (let [input (cli/parse-opts args spamgen-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [  test help]} options]\n    \n    (pln :inp input)\n    (pln :options options)\n\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    spamgen &lt;input-edn&gt; options*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      :default (do\n                 #_ (email-batch-to-sendfiles &lt;tbd&gt;)\n                 (println :fnyi))\n      ))\n\n  ;; WARNING: comment this out for use with REPL\n  ;;(shutdown-agents)\n  )&quot;, :offset 1011, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot; \&quot;-t42\&quot;)&quot;, :offset 37, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot; \&quot;-h\&quot; \&quot;-t0\&quot;)&quot;, :offset 41, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot; \&quot;-h\&quot; \&quot;-tx\&quot;)&quot;, :offset 41, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot; \&quot;-h\&quot; \&quot;-t\&quot;)&quot;, :offset 40, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot; \&quot;-h\&quot; \&quot;-t42\&quot;)&quot;, :offset 42, :ns &quot;spamgen.core&quot;} {:command &quot;(bulk-input-build \&quot;emf\&quot; 1000)&quot;, :offset 29, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n  (pln :stream! email-stream (first email-stream))\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (pln :do-em em-rec)\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2255, :ns &quot;spamgen.core&quot;} {:command &quot;(def spamgen-cli\n  [[\&quot;-t\&quot; \&quot;--test TESTCOUNT\&quot; \&quot;Number of test email records to process ignoring file arg\&quot;\n    :default 100\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1)\&quot;]]\n\n   [\&quot;-d\&quot; \&quot;--dump DUMPCOUNT\&quot; \&quot;Number of output email records to dump, per target IP\&quot;\n    :default 10\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1) if specified\&quot;]]\n   \n   [\&quot;-h\&quot; \&quot;--help\&quot;]]\n  )&quot;, :offset 469, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;-h\&quot;)&quot;, :offset 12, :ns &quot;spamgen.core&quot;} {:command &quot;(def spamgen-cli\n  [[\&quot;-t\&quot; \&quot;--test TESTCOUNT\&quot; \&quot;Number of test email records to process ignoring file arg\&quot;\n    :default 100\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1)\&quot;]]\n\n   [\&quot;-d\&quot; \&quot;--dump DUMPCOUNT\&quot; \&quot;Number of output email records to dump, per target IP\&quot;\n    ;;:default 10\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1) if specified\&quot;]]\n   \n   [\&quot;-h\&quot; \&quot;--help\&quot;]]\n  )&quot;, :offset 471, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot;)&quot;, :offset 30, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot; \&quot;-d\&quot;)&quot;, :offset 35, :ns &quot;spamgen.core&quot;} {:command &quot;(def spamgen-cli\n  [[\&quot;-t\&quot; \&quot;--test TESTCOUNT\&quot; \&quot;Number of test email records to process ignoring file arg\&quot;\n    :default 100\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1)\&quot;]]\n\n   [\&quot;-d\&quot; \&quot;--dump DUMPCOUNT\&quot; \&quot;Number of output email records to dump, per target IP\&quot;\n    ;;:default 10\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1) if specified\&quot;]]\n\n   [\&quot;-h\&quot; \&quot;--help\&quot;]])&quot;, :offset 465, :ns &quot;spamgen.core&quot;} {:command &quot;(def spamgen-cli\n  [[\&quot;-t\&quot; \&quot;--test TESTCOUNT\&quot; \&quot;Number of test email records to process ignoring file arg\&quot;\n    ;;:default 100\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1)\&quot;]]\n\n   [\&quot;-d\&quot; \&quot;--dump DUMPCOUNT\&quot; \&quot;Number of output email records to dump, per target IP\&quot;\n    ;;:default 10\n    :parse-fn #(Integer/parseInt %)\n    :validate [#(&lt;= 1 %) \&quot;Must be a number greater than one (1) if specified\&quot;]]\n\n   [\&quot;-h\&quot; \&quot;--help\&quot;]])&quot;, :offset 467, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-10.edn\&quot; \&quot;-d10\&quot;)&quot;, :offset 37, :ns &quot;spamgen.core&quot;} {:command &quot;(-main \&quot;bulkinput/emf-1000.edn\&quot; \&quot;-t100\&quot; \&quot;-d10\&quot;)&quot;, :offset 47, :ns &quot;spamgen.core&quot;} {:command &quot;(declare email-stream-to-sendfiles\n  emw-email-consider \n  running-mean-ok?\n  edn-dump pln)&quot;, :offset 91, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n\n    (p ::send-50k\n      (email-stream-to-sendfiles\n        (email-records-test-gen 5000)))))&quot;, :offset 142, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest infile-edn\n  (pln :startedn)\n  (email-batch-to-sendfiles \&quot;bulkinput/emf-1000.edn\&quot; 100)\n  #_\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-1000.edn\&quot;))]\n    (pln :ednin in)\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (pln :eseq (take-while (partial not= :fini) edn-seq))\n      (email-batch-to-sendfiles (take-while (partial not= :fini) edn-seq)))))&quot;, :offset 419, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest infile-edn\n  (pln :startedn)\n  (email-batch-to-sendfiles \&quot;bulkinput/emf-1000.edn\&quot;)\n  #_\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-1000.edn\&quot;))]\n    (pln :ednin in)\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (pln :eseq (take-while (partial not= :fini) edn-seq))\n      (email-batch-to-sendfiles (take-while (partial not= :fini) edn-seq)))))&quot;, :offset 415, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-batch-to-sendfiles [batch-input-path]\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader batch-input-path))]\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (email-stream-to-sendfiles\n        (take-while (partial not= :fini) edn-seq)))))&quot;, :offset 289, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n  \n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_ (pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_ (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:max-overall-spam-score env)))\n\n        ;;(not (running-mean-ok? w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        ;;(do (pln :running-mean-bad (:spam-score task)))\n\n        :default\n        (when true #_(dosync\n                       ;; todo make sure addr key matches generator when testing\n                       ;; or work out how to normalize keys in spec\n                       (let [addr (:email-address task)]\n                         (when-not (get @(:addrs-hit w) addr)\n                           (alter (:addrs-hit w) conj addr)\n                           true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          ;; (pln :sending-to (:id w) (:email-address task))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 1846, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest infile-stream-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-1000.edn\&quot;))]\n    (pln :ednin in)\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (pln :eseq (take-while (partial not= :fini) edn-seq))\n      (email-stream-to-sendfiles (take-while (partial not= :fini) edn-seq)))))&quot;, :offset 346, :ns &quot;spamgen.core-test&quot;} {:command &quot;(bulk-input-build \&quot;emf\&quot; 100)&quot;, :offset 28, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n  (pln :task! task)\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_ (pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_ (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:max-overall-spam-score env)))\n\n        ;;(not (running-mean-ok? w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        ;;(do (pln :running-mean-bad (:spam-score task)))\n\n        :default\n        (when true #_(dosync\n                       ;; todo make sure addr key matches generator when testing\n                       ;; or work out how to normalize keys in spec\n                       (let [addr (:email-address task)]\n                         (when-not (get @(:addrs-hit w) addr)\n                           (alter (:addrs-hit w) conj addr)\n                           true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          ;; (pln :sending-to (:id w) (:email-address task))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 1863, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n  (pln :stream! email-stream (first email-stream))\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n    \n    (pln :waiting-on-workers)\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2256, :ns &quot;spamgen.core&quot;} {:command &quot;(defn -main [&amp; args]\n  ;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what :uncaught-exception\n                        :exception ex\n                        :where (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n\n  (pln :main args )\n\n  (let [input (cli/parse-opts args spamgen-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [test help]} options]\n\n    (pln :inp input)\n    (pln :options options)\n\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    spamgen &lt;input-edn&gt; options*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      :default (do\n                 #_ (email-batch-to-sendfiles &lt;tbd&gt;)\n                 (println :fnyi))\n      ))\n\n  ;; WARNING: comment this out for use with REPL. Necessary, to\n  ;; get standalone version to exit reliably.\n  ;;\n  ;; (shutdown-agents)\n  )&quot;, :offset 1064, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest infile-stream-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n    (pln :ednin in)\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      ;; (pln :eseq (take-while (partial not= :fini) edn-seq))\n      (email-stream-to-sendfiles (take-while (partial not= :fini) edn-seq))\n      (doseq [erec (take-while (partial not= :fini) edn-seq)]\n        (pln :erec erec))\n      (pln :infile-stream-edn-fini))))&quot;, :offset 472, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest infile-stream-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n    (pln :ednin in)\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      ;; (pln :eseq (take-while (partial not= :fini) edn-seq))\n      ;;(email-stream-to-sendfiles (take-while (partial not= :fini) edn-seq))\n      (doseq [erec (take-while (partial not= :fini) edn-seq)]\n        (pln :erec erec))\n      (pln :infile-stream-edn-fini))))&quot;, :offset 474, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest infile-stream-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n    (pln :ednin in)\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      ;; (pln :eseq (take-while (partial not= :fini) edn-seq))\n      (email-stream-to-sendfiles (take-while (partial not= :fini) edn-seq))\n      #_(doseq [erec (take-while (partial not= :fini) edn-seq)]\n        (pln :erec erec))\n      (pln :infile-stream-edn-fini))))&quot;, :offset 474, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-stream-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n  (pln :stream! email-stream (first email-stream))\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-email-consider w task)\n                                  (recur))\n                                (do\n                                  (pln :worker-fini (:id w))\n                                  [:fini (:id w)]))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    \n    (pln :spit-init)\n    \n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (pln :feeding)\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (pln :waiting-on-workers)\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2388, :ns &quot;spamgen.core&quot;} {:command &quot;(edn-dump \&quot;bulkinput/emf-10.edn\&quot;)&quot;, :offset 33, :ns &quot;spamgen.core-test&quot;} {:command &quot;(with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n  (pln :ednin in)\n  (let [edn-seq (repeatedly (edn/read {:eof :fini} in))]\n    (pln (take 5 edn-seq))\n    (pln :infile-stream-edn-fini)))&quot;, :offset 228, :ns &quot;spamgen.core-test&quot;} {:command &quot;(with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n  (pln :ednin in)\n  (let [edn-seq (repeatedly (edn/read {:eof :fini} in))]\n    (pln :eseq edn)\n    (pln (take 5 edn-seq))\n    (pln :infile-stream-edn-fini)))&quot;, :offset 248, :ns &quot;spamgen.core-test&quot;} {:command &quot;(with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n  (pln :ednin in)\n  (let [edn-seq (repeatedly (edn/read {:eof :fini} in))]\n    (pln :eseq edn-seq)\n    (pln (take 5 edn-seq))\n    (pln :infile-stream-edn-fini)))&quot;, :offset 252, :ns &quot;spamgen.core-test&quot;} {:command &quot;(with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n  (pln :ednin in)\n  #_\n  (let [edn-seq (repeatedly (edn/read {:eof :fini} in))]\n    (pln :eseq edn-seq)\n    (pln (take 5 edn-seq))\n    (pln :infile-stream-edn-fini)))&quot;, :offset 257, :ns &quot;spamgen.core-test&quot;} {:command &quot;(with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n  (pln :ednin in)\n  \n  (let [edn-seq (repeatedly (edn/read {:eof :fini} in))]\n    (pln :eseq edn-seq)\n    ;(pln (take 5 edn-seq))\n    (pln :infile-stream-edn-fini)))&quot;, :offset 256, :ns &quot;spamgen.core-test&quot;} {:command &quot;(with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n  (pln :ednin in)\n  \n  (let [edn-seq (repeatedly #(edn/read {:eof :fini} in))]\n    (pln :eseq edn-seq)\n    ;(pln (take 5 edn-seq))\n    (pln :infile-stream-edn-fini)))&quot;, :offset 257, :ns &quot;spamgen.core-test&quot;} {:command &quot;(with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n  (pln :ednin in)\n  (let [edn-seq (repeatedly #(edn/read {:eof :fini} in))]\n    (pln :eseq edn-seq)\n    ;(pln (take 5 edn-seq))\n    (pln :infile-stream-edn-fini)))&quot;, :offset 254, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn edn-pull\n  ([in] (edn-pull (edn/read {:eof :fini} in)))\n  ([in erec] (lazy-seq (cons erec (edn-pull (edn/read {:eof :fini} in))))))&quot;, :offset 137, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest just-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n    (pln :ednin in)\n    (println (take 1 (edn-pull in)))\n    #_\n    (let [edn-seq (repeatedly #(edn/read {:eof :fini} in))]\n      (pln :eseq edn-seq)\n      ;(pln (take 5 edn-seq))\n      (pln :infile-stream-edn-fini))))&quot;, :offset 329, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest just-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n    (pln :ednin in)\n    (println (edn-pull in))\n    #_\n    (let [edn-seq (repeatedly #(edn/read {:eof :fini} in))]\n      (pln :eseq edn-seq)\n      ;(pln (take 5 edn-seq))\n      (pln :infile-stream-edn-fini))))&quot;, :offset 320, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn edn-pull\n  ([in] (edn-pull in (edn/read {:eof :fini} in)))\n  ([in erec] (lazy-seq (cons erec (edn-pull (edn/read {:eof :fini} in))))))&quot;, :offset 140, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn edn-pull\n  ([in] \n   (pln :in1 in)\n   (edn-pull in (edn/read {:eof :fini} in)))\n  ([in erec] (lazy-seq (cons erec (edn-pull (edn/read {:eof :fini} in))))))&quot;, :offset 161, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn edn-pull\n  ([in]\n   (pln :in1 in)\n   (edn-pull in (edn/read {:eof :fini} in)))\n  ([in erec] (lazy-seq (cons erec (edn-pull in (edn/read {:eof :fini} in))))))&quot;, :offset 163, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest just-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-10.edn\&quot;))]\n    (pln :ednin in)\n    (println (take 15 (edn-pull in)))\n    #_\n    (let [edn-seq (repeatedly #(edn/read {:eof :fini} in))]\n      (pln :eseq edn-seq)\n      ;(pln (take 5 edn-seq))\n      (pln :infile-stream-edn-fini))))&quot;, :offset 329, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest just-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-10.edn\&quot;))]\n    (pln :ednin in)\n    (println (take-while (partial not= :fini) (edn-pull in)))\n    #_\n    (let [edn-seq (repeatedly #(edn/read {:eof :fini} in))]\n      (pln :eseq edn-seq)\n      ;(pln (take 5 edn-seq))\n      (pln :infile-stream-edn-fini))))&quot;, :offset 353, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest just-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-10.edn\&quot;))]\n    (pln :ednin in)\n    (println (take-while (partial not= :fini) (edn-pull in)))\n    (email-stream-to-sendfiles (take-while (partial not= :fini) (edn-pull in)))\n    #_\n    (let [edn-seq (repeatedly #(edn/read {:eof :fini} in))]\n      (pln :eseq edn-seq)\n      ;(pln (take 5 edn-seq))\n      (pln :infile-stream-edn-fini))))&quot;, :offset 433, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest just-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-100.edn\&quot;))]\n    (pln :ednin in)\n    ;; (println (take-while (partial not= :fini) (edn-pull in)))\n    (email-stream-to-sendfiles (take-while (partial not= :fini) (edn-pull in)))))&quot;, :offset 277, :ns &quot;spamgen.core-test&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.main">
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
    <configuration name="main" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="1" />
      <module name="spamgen" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="" />
      <created>1521628166875</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1521628166875</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="93" y="67" width="1531" height="886" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.3435663" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.13912475" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
    </layout>
    <layout-to-restore>
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.32931727" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="false" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.14257029" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
    </layout-to-restore>
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <option name="time" value="1" />
    </breakpoint-manager>
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="153">
          <caret line="9" column="0" lean-forward="false" selection-start-line="9" selection-start-column="0" selection-end-line="9" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="17">
          <caret line="1" column="0" lean-forward="true" selection-start-line="1" selection-start-column="0" selection-end-line="1" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="18" lean-forward="true" selection-start-line="7" selection-start-column="18" selection-end-line="7" selection-end-column="18" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="249">
          <caret line="3207" column="10" lean-forward="false" selection-start-line="3207" selection-start-column="10" selection-end-line="3207" selection-end-column="10" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="452">
          <caret line="47" column="41" lean-forward="false" selection-start-line="47" selection-start-column="41" selection-end-line="47" selection-end-column="41" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="357">
          <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/config/dev/config.edn">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="170">
          <caret line="10" column="2" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="10" selection-end-column="2" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="238">
          <caret line="14" column="16" lean-forward="false" selection-start-line="14" selection-start-column="16" selection-end-line="14" selection-end-column="16" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="446">
          <caret line="72" column="70" lean-forward="true" selection-start-line="72" selection-start-column="70" selection-end-line="72" selection-end-column="70" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>