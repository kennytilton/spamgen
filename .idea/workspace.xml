<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="">
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/project.clj" afterPath="$PROJECT_DIR$/project.clj" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/src/spamgen/core.clj" afterPath="$PROJECT_DIR$/src/spamgen/core.clj" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="project.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="144">
              <caret line="9" column="46" lean-forward="false" selection-start-line="9" selection-start-column="46" selection-end-line="9" selection-end-column="46" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="config.edn" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/config/dev/config.edn">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="170">
              <caret line="10" column="2" lean-forward="false" selection-start-line="10" selection-start-column="2" selection-end-line="10" selection-end-column="2" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core_test.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="315">
              <caret line="29" column="22" lean-forward="true" selection-start-line="29" selection-start-column="22" selection-end-line="29" selection-end-column="22" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.clj" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="23">
              <caret line="28" column="43" lean-forward="false" selection-start-line="28" selection-start-column="43" selection-end-line="28" selection-end-column="43" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="genlist.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="452">
              <caret line="47" column="41" lean-forward="false" selection-start-line="47" selection-start-column="41" selection-end-line="47" selection-end-column="41" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>test-email-records</find>
      <find>println</find>
      <find>:sent</find>
    </findStrings>
    <replaceStrings>
      <replace>em-addrs-hit</replace>
      <replace>:addrs-hit</replace>
    </replaceStrings>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/resources/config.edn" />
        <option value="$PROJECT_DIR$/src/spamgen/genlist.clj" />
        <option value="$PROJECT_DIR$/config/dev/config.edn" />
        <option value="$PROJECT_DIR$/test/spamgen/core_test.clj" />
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/src/spamgen/core.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds">
    <option name="x" value="93" />
    <option name="y" value="67" />
    <option name="width" value="1494" />
    <option name="height" value="886" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="AndroidView" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
              <item name="dev" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="Scope" />
      <pane id="PackagesPane" />
      <pane id="Scratches" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="configurable.group.build" />
    <property name="cursive.last.file.extension./Users/kennethtilton/spamgen/src" value="clj" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/config/dev" />
    </key>
  </component>
  <component name="ReplState" timestamp="1521716290573">{:repl-history {:ide [], :local [{:command &quot;(let [last-n 5]\n  (loop [x 4\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (if (empty? (:ns stats))\n                   (list new-n)\n                   (concat (pop (:ns stats)) (list new-n)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 742, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 3\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (if (empty? (:ns stats))\n                   (list new-n)\n                   (concat (pop (:ns stats)) (list new-n)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 742, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 2\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (if (empty? (:ns stats))\n                   (list new-n)\n                   (concat (pop (:ns stats)) (list new-n)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 742, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 2\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (if (empty? (:ns stats))\n                   (list new-n)\n                   (do\n                     (pln :adding new-n (:ns stats))\n                     (concat (pop (:ns stats)) (list new-n))))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 821, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 2\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (take last-n (concat (:ns stats)(list new-n)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 672, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 4\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (take last-n (concat (:ns stats)(list new-n)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 672, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 6\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (take last-n (concat (:ns stats)(list new-n)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 672, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 7\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (take last-n (concat (:ns stats)(list new-n)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 672, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 7\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (let [nsn (concat (:ns stats)(list new-n))]\n                   (if (&lt;= new-ct last-n)\n                     nsn (take last-n nsn)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 756, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 7\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (let [nsn (concat (:ns stats)(list new-n))]\n                   (if (&lt; new-ct last-n)\n                     nsn (take last-n nsn)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 755, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 3\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (let [nsn (concat (:ns stats)(list new-n))]\n                   (if (&lt; new-ct last-n)\n                     nsn (take last-n nsn)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 755, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 4\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (let [nsn (concat (:ns stats)(list new-n))]\n                   (if (&lt; new-ct last-n)\n                     nsn (take last-n nsn)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 755, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 5\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n 2 #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (let [nsn (concat (:ns stats)(list new-n))]\n                   (if (&lt; new-ct last-n)\n                     nsn (take last-n nsn)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 755, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 5\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n (:ct state) #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (let [nsn (concat (:ns stats)(list new-n))]\n                   (if (&lt; new-ct last-n)\n                     nsn (take last-n nsn)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 765, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 5\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n (:ct stats) #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 3)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (let [nsn (concat (:ns stats)(list new-n))]\n                   (if (&lt; new-ct last-n)\n                     nsn (take last-n nsn)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 765, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 5\n         stats {:ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n (:ct stats) #_ (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 1.5)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {:ns (let [nsn (concat (:ns stats)(list new-n))]\n                   (if (&lt; new-ct last-n)\n                     nsn (take last-n nsn)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 767, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 5\n         stats {;; :ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 1.5)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {\n             ;:ns (let [nsn (concat (:ns stats)(list new-n))]\n             ;      (if (&lt; new-ct last-n)\n             ;        nsn (take last-n nsn)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 772, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [last-n 5]\n  (loop [x 5\n         stats {;; :ns (list)\n                :ct 0\n                :mean 0}]\n    (cond\n      (&lt;= x 0) (println :fini stats)\n      :default\n      (let [new-n (rand-int 10)\n            new-ct (min last-n (inc (:ct stats)))\n            new-mean (+ (:mean stats)\n                       (/  (- new-n (:mean stats)) new-ct))]\n        (cond\n          (&gt; new-mean 5)\n          (do\n            (pln :newm-high (:mean stats) new-n new-ct new-mean)\n            (recur (dec x) stats))\n\n          :default\n          (recur (dec x)\n            {\n             ;:ns (let [nsn (concat (:ns stats)(list new-n))]\n             ;      (if (&lt; new-ct last-n)\n             ;        nsn (take last-n nsn)))\n             :ct new-ct\n             :mean new-mean}))))))&quot;, :offset 770, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [x (atom {:a 1 :b 2})]\n  (swap! x merge {:a 7 :b 9}))&quot;, :offset 58, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn running-mean-ok? [w new-score]\n  (let [stats @(:stats w)\n        last-n (:running-mean-span env) \n        new-ct (min last-n (inc (:em-ct stats)))\n        new-mean (+ (:running-mean stats)\n                   (/ (- new-score (:mean stats)) new-ct))]\n    (cond\n      (&gt; new-mean 5)\n      (do\n        (pln :newm-high (:running-mean stats) new-score new-ct new-mean)\n        false)\n\n      :default\n      (do \n        (swap! (:stats w) merge {:em-ct new-ct\n                                 :running-mean new-mean})\n        true))))&quot;, :offset 532, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn running-mean-ok? [w new-score]\n  (let [stats @(:stats w)\n        last-n (:running-mean-span env) \n        running-mean (:running-mean stats)\n        new-ct (min last-n (inc (:em-ct stats)))\n        new-mean (+ running-mean\n                   (/ (- new-score running-mean) new-ct))]\n    (cond\n      (&gt; new-mean 5)\n      (do\n        (pln :newmean-too-high new-mean (:running-mean stats) new-score new-ct)\n        false)\n\n      :default\n      (do \n        (swap! (:stats w) merge {:em-ct new-ct\n                                 :running-mean new-mean})\n        true))))&quot;, :offset 572, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn running-mean-ok? [w new-score]\n  (let [stats @(:stats w)\n        last-n (:running-mean-span env) \n        running-mean (:running-mean stats)\n        new-ct (min last-n (inc (:em-ct stats)))\n        new-mean (+ running-mean\n                   (/ (- new-score running-mean) new-ct))]\n    (cond\n      (&gt; new-mean (:running-mean-max env))\n      (do\n        (pln :newmean-too-high new-mean (:running-mean stats) new-score new-ct)\n        false)\n\n      :default\n      (do \n        (swap! (:stats w) merge {:em-ct new-ct\n                                 :running-mean new-mean})\n        true))))&quot;, :offset 594, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn running-mean-ok? [w new-score]\n  (let [stats @(:stats w)\n        running-span (:running-mean-span env)\n        running-mean (:running-mean stats)\n        new-ct (min running-span (inc (:em-ct stats)))\n        new-mean (+ running-mean\n                   (/ (- new-score running-mean) new-ct))]\n    (cond\n      (&gt;= new-mean (:running-mean-max env))\n      (do\n        (pln :newmean-too-high new-mean (:running-mean stats) new-score new-ct)\n        false)\n\n      :default\n      (do\n        (swap! (:stats w) merge {:em-ct new-ct\n                                 :running-mean new-mean})\n        true))))&quot;, :offset 605, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn emw-consider [w task]\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_(pln :email-mean-bad :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)))\n\n        (not (running-mean-ok? w  (:spam-score task)))\n        (do (pln :running-bad)(:spam-score task))\n\n        :default\n        (let [go (atom true)]\n          (dosync\n            ;;;(pln :sent @(:sent w))\n            ;; todo make sure addr key matches generator\n            (let [addr (:email-address task)]\n              (if (get @(:sent w) addr)\n                (reset! go false)\n                (alter (:sent w) conj addr))))\n          (when @go\n            (swap! (:stats w) assoc :em-ct new-ct)\n            (swap! (:stats w) assoc :score-sum new-sum)\n            #_(pln :sending :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct))\n            (pln :sending-to (:email-address-duped task))\n            (spit (:out-file w) task :append true)))))))&quot;, :offset 1295, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [x (list 1 2 3)]\n    (concat (pop x) [4]))&quot;, :offset 47, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn running-mean-ok? [w new-score]\n  (pln :rmok-entry @(:stats w))\n  (let [stats @(:stats w)\n        running-span (:running-mean-span env)\n        running-mean (:running-mean stats)\n        new-ct (min running-span (inc (:em-ct stats)))\n        new-mean (+ running-mean\n                   (/ (- new-score running-mean) new-ct))]\n    (cond\n      (&gt;= new-mean (:running-mean-max env))\n      (do\n        (pln :newmean-too-high new-mean (:running-mean stats) new-score new-ct)\n        false)\n\n      :default\n      (do\n        (swap! (:stats w) merge {:em-ct new-ct\n                                 :running-mean new-mean})\n        true))))&quot;, :offset 637, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn running-mean-ok? [w new-score]\n  (pln :rmok-entry (:running-mean stats) @(:stats w))\n  (let [stats @(:stats w)\n        running-span (:running-mean-span env)\n        running-mean (:running-mean stats)\n        new-ct (min running-span (inc (:em-ct stats)))\n        new-mean (+ running-mean\n                   (/ (- new-score running-mean) new-ct))]\n    (cond\n      (&gt;= new-mean (:running-mean-max env))\n      (do\n        (pln :newmean-too-high new-mean (:running-mean stats) new-score new-ct)\n        false)\n\n      :default\n      (do\n        (swap! (:stats w) merge {:em-ct new-ct\n                                 :running-mean new-mean})\n        true))))&quot;, :offset 659, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn running-mean-ok? [w new-score]\n  (pln :rmok-entry (:running-mean-max env) @(:stats w))\n  (let [stats @(:stats w)\n        running-span (:running-mean-span env)\n        running-mean (:running-mean stats)\n        new-ct (min running-span (inc (:em-ct stats)))\n        new-mean (+ running-mean\n                   (/ (- new-score running-mean) new-ct))]\n    (cond\n      (&gt;= new-mean (:running-mean-max env))\n      (do\n        (pln :newmean-too-high new-mean (:running-mean stats) new-score new-ct)\n        false)\n\n      :default\n      (do\n        (swap! (:stats w) merge {:em-ct new-ct\n                                 :running-mean new-mean})\n        true))))&quot;, :offset 661, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn running-mean-ok? [w new-score]\n  ;(pln :rmok-entry new-score (:running-mean-max env) @(:stats w))\n  (let [stats @(:stats w)\n        running-span (:running-mean-span env)\n        running-mean (:running-mean stats)\n        new-ct (min running-span (inc (:em-ct stats)))\n        new-mean (+ running-mean\n                   (/ (- new-score running-mean) new-ct))]\n    (cond\n      (&gt;= new-mean (:running-mean-max env))\n      (do\n        (pln :running-mean-too-high new-mean (:running-mean stats) new-score new-ct)\n        false)\n\n      :default\n      (do\n        (swap! (:stats w) merge {:em-ct new-ct\n                                 :running-mean new-mean})\n        true))))&quot;, :offset 677, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn test-email-records [email-generator]\n\n  (let [emails-sent (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id       id\n                        :smptp-ip smtp-ip\n                        :ch       (chan)\n                        :sent     emails-sent\n                        :out-file (str\n                                    (:bulkmail-out-path env) \&quot;/\&quot;\n                                    smtp-ip \&quot;.txt\&quot;)\n                        :stats    (atom {:em-ct        0\n                                         :running-mean 0\n                                         :score-sum    0})})\n                  (range)\n\n                  (take (min (count (:smtp env))\n                              (:worker-ct env))\n                    (:smtp env)))\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    (doseq [w workers]\n      (pln :spitting-to (:out-file w))\n      (spit (:out-file w) {:run-date (.toString (java.util.Date.))}))\n\n    (pln :feeding (count workers))\n\n    (doall\n      (map (fn [worker em-rec]\n             ;(pln :out em-rec)\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        (email-records-duped-test-gen 40)))\n\n    (pln :start-waiting (count work-procs))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (pln :waiting-first p)\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (pln :worker-completed out :rem (count rp))\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 1928, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn emw-consider [w task]\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_(pln :email-mean-bad :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)))\n\n        (not (running-mean-ok? w  (:spam-score task)))\n        (do (pln :running-bad)(:spam-score task))\n\n        :default\n        (let [go (atom true)]\n          (dosync\n            ;;;(pln :sent @(:sent w))\n            ;; todo make sure addr key matches generator\n            (let [addr (:email-address task)]\n              (if (get @(:sent w) addr)\n                (reset! go false)\n                (alter (:sent w) conj addr))))\n          (when @go\n            (swap! (:stats w) assoc :em-ct new-ct)\n            (swap! (:stats w) assoc :score-sum new-sum)\n            #_(pln :sending :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct))\n            (pln :sending-to (:id w)(:email-address-duped task))\n            (spit (:out-file w) task :append true)))))))&quot;, :offset 1302, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn emw-consider [w task]\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_(pln :email-mean-bad :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)))\n\n        (not (running-mean-ok? w  (:spam-score task)))\n        (do (pln :running-bad)(:spam-score task))\n\n        :default\n        (let [go (atom true)]\n          (dosync\n            ;;;(pln :sent @(:sent w))\n            ;; todo make sure addr key matches generator\n            (let [addr (:email-address task)]\n              (if (get @(:sent w) addr)\n                (reset! go false)\n                (alter (:sent w) conj addr))))\n          (when @go\n            (swap! (:stats w) assoc :em-ct new-ct)\n            (swap! (:stats w) assoc :score-sum new-sum)\n            #_(pln :sending :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct))\n            (pln :sending-to (:id w)(:email-address task))\n            (spit (:out-file w) task :append true)))))))&quot;, :offset 1296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(email-records-test-gen 3)&quot;, :offset 26, :ns &quot;spamgen.genlist&quot;} {:command &quot;(defn test-email-records [email-generator]\n\n  (let [emails-sent (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id       id\n                        :smptp-ip smtp-ip\n                        :ch       (chan)\n                        :sent     emails-sent\n                        :out-file (str\n                                    (:bulkmail-out-path env) \&quot;/\&quot;\n                                    smtp-ip \&quot;.txt\&quot;)\n                        :stats    (atom {:em-ct        0\n                                         :running-mean 0\n                                         :score-sum    0})})\n                  (range)\n\n                  (take (min (count (:smtp env))\n                              (:worker-ct env))\n                    (:smtp env)))\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    (doseq [w workers]\n      (pln :spitting-to (:out-file w))\n      (spit (:out-file w) {:run-date (.toString (java.util.Date.))}))\n\n    (pln :feeding (count workers))\n\n    (doall\n      (map (fn [worker em-rec]\n             ;(pln :out em-rec)\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        (email-generator 40)))\n\n    (pln :start-waiting (count work-procs))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (pln :waiting-first p)\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (pln :worker-completed out :rem (count rp))\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 1915, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn emw-consider [w task]\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do (pln :email-mean-bad :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)))\n\n        (not (running-mean-ok? w  (:spam-score task)))\n        (do (pln :running-bad)(:spam-score task))\n\n        :default\n        (let [go (atom true)]\n          (dosync\n            ;;;(pln :sent @(:sent w))\n            ;; todo make sure addr key matches generator\n            (let [addr (:email-address task)]\n              (if (get @(:sent w) addr)\n                (reset! go false)\n                (alter (:sent w) conj addr))))\n          (when @go\n            (swap! (:stats w) assoc :em-ct new-ct)\n            (swap! (:stats w) assoc :score-sum new-sum)\n            #_(pln :sending :w (:id w) :score (:spam-score task)\n                :new-mean (/ new-sum new-ct))\n            (pln :sending-to (:id w)(:email-address task))\n            (spit (:out-file w) task :append true)))))))&quot;, :offset 1294, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn test-email-records [email-generator]\n\n  (let [emails-sent (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id       id\n                        :smptp-ip smtp-ip\n                        :ch       (chan)\n                        :sent     emails-sent\n                        :out-file (str\n                                    (:bulkmail-out-path env) \&quot;/\&quot;\n                                    smtp-ip \&quot;.txt\&quot;)\n                        :stats    (atom {:em-ct        0\n                                         :running-mean 0\n                                         :score-sum    0})})\n                  (range)\n\n                  (take (min (count (:smtp env))\n                              (:worker-ct env))\n                    (:smtp env)))\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    (doseq [w workers]\n      (pln :spitting-to (:out-file w))\n      (spit (:out-file w) {:run-date (.toString (java.util.Date.))}))\n\n    (pln :feeding (count workers))\n\n    (doall\n      (map (fn [worker em-rec]\n             ;(pln :out em-rec)\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (pln :start-waiting (count work-procs))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (pln :waiting-first p)\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (pln :worker-completed out :rem (count rp))\n          (recur rp))))\n\n    (println :fini)\n\n    (doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 1905, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn test-email-records [email-stream]\n\n  (let [emails-sent (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id       id\n                        :smptp-ip smtp-ip\n                        :ch       (chan)\n                        :sent     emails-sent\n                        :out-file (str\n                                    (:bulkmail-out-path env) \&quot;/\&quot;\n                                    smtp-ip \&quot;.txt\&quot;)\n                        :stats    (atom {:em-ct        0\n                                         :running-mean 0\n                                         :score-sum    0})})\n                  (range)\n\n                  (take (min (count (:smtp env))\n                              (:worker-ct env))\n                    (:smtp env)))\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    (doseq [w workers]\n      (pln :spitting-to (:out-file w))\n      (spit (:out-file w) {:run-date (.toString (java.util.Date.))}))\n\n    (pln :feeding (count workers))\n\n    (doall\n      (map (fn [worker em-rec]\n             ;(pln :out em-rec)\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (pln :start-waiting (count work-procs))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (pln :waiting-first p)\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (pln :worker-completed out :rem (count rp))\n          (recur rp))))\n\n    (println :fini)\n\n    #_ (doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 1905, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn emw-consider [w task]\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n                 :new-mean (/ new-sum new-ct)))\n\n        (not (running-mean-ok? w  (:spam-score task)))\n        (do (pln :running-bad)\n            (:spam-score task))\n\n        :default\n        (let [go (atom true)]\n          (dosync\n            ;;;(pln :sent @(:sent w))\n            ;; todo make sure addr key matches generator\n            (let [addr (:email-address task)]\n              (if (get @(:sent w) addr)\n                (reset! go false)\n                (alter (:sent w) conj addr))))\n          (when @go\n            (swap! (:stats w) merge {:em-ct new-ct\n                                     :score-sum new-sum})\n\n            ;;; todo batch spits\n            (pln :sending-to (:id w)(:email-address task))\n            (spit (:out-file w) task :append true)))))))&quot;, :offset 1241, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles [email-stream]\n\n  (let [emails-sent (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id       id\n                        :smptp-ip smtp-ip\n                        :ch       (chan)\n                        :sent     emails-sent\n                        :out-file (str\n                                    (:bulkmail-out-path env) \&quot;/\&quot;\n                                    smtp-ip \&quot;.txt\&quot;)\n                        :stats    (atom {:em-ct        0\n                                         :running-mean 0\n                                         :score-sum    0})})\n                  (range)\n\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    (doseq [w workers]\n      (pln :spitting-to (:out-file w))\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip (:smtp-ip w)}))\n\n    (pln :feeding (count workers))\n\n    (doall\n      (map (fn [worker em-rec]\n             ;(pln :out em-rec)\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (pln :start-waiting (count work-procs))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (pln :waiting-first p)\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (pln :worker-completed out :rem (count rp))\n          (recur rp))))\n\n    (println :fini)\n\n    #_ (doseq [w workers]\n         (edn-dump (:out-file w)))))&quot;, :offset 1947, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles [email-stream]\n\n  (let [emails-sent (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id       id\n                        :smtp-ip smtp-ip\n                        :ch       (chan)\n                        :sent     emails-sent\n                        :out-file (str\n                                    (:bulkmail-out-path env) \&quot;/\&quot;\n                                    smtp-ip \&quot;.txt\&quot;)\n                        :stats    (atom {:em-ct        0\n                                         :running-mean 0\n                                         :score-sum    0})})\n                  (range)\n\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    (doseq [w workers]\n      (pln :spitting-to (:out-file w))\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip (:smtp-ip w)}))\n\n    (pln :feeding (count workers))\n\n    (doall\n      (map (fn [worker em-rec]\n             ;(pln :out em-rec)\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (pln :start-waiting (count work-procs))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (pln :waiting-first p)\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (pln :worker-completed out :rem (count rp))\n          (recur rp))))\n\n    (println :fini)\n\n    #_ (doseq [w workers]\n         (edn-dump (:out-file w)))))&quot;, :offset 1946, :ns &quot;spamgen.core&quot;} {:command &quot;{\n :smtp [\&quot;1.2.3.4\&quot; \&quot;10.20.30.40\&quot; \&quot;100.200.101.201\&quot;\n        \&quot;11.22.33.44\&quot; \&quot;111.112.113.114\&quot; \&quot;22.33.44.55\&quot;]\n :worker-ct 6\n :max-individual-spam-score 0.3\n :max-overall-spam-score 0.05\n :running-mean-max 0.1\n :running-mean-span 100\n :total-email-ct 100\n :bulkmail-out-path \&quot;bulkmail\&quot;\n }&quot;, :offset 284, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles [email-stream]\n\n  (let [emails-sent (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id       id\n                        :smtp-ip smtp-ip\n                        :ch       (chan)\n                        :sent     emails-sent\n                        :out-file (str\n                                    (:bulkmail-out-path env) \&quot;/\&quot;\n                                    smtp-ip \&quot;.txt\&quot;)\n                        :stats    (atom {:em-ct        0\n                                         :running-mean 0\n                                         :score-sum    0})})\n                  (range)\n\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    (doseq [w workers]\n      (pln :spitting-to  (:smtp-ip w))\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip (:smtp-ip w)}))\n\n    (pln :feeding (count workers))\n\n    (doall\n      (map (fn [worker em-rec]\n             ;(pln :out em-rec)\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (pln :start-waiting (count work-procs))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (pln :waiting-first p)\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (pln :worker-completed out :rem (count rp))\n          (recur rp))))\n\n    (println :fini)\n\n    #_ (doseq [w workers]\n         (edn-dump (:out-file w)))))&quot;, :offset 1946, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles [email-stream]\n\n  (let [emails-sent (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id       id\n                        :smtp-ip smtp-ip\n                        :ch       (chan)\n                        :sent     emails-sent\n                        :out-file (str\n                                    (:bulkmail-out-path env) \&quot;/\&quot;\n                                    smtp-ip \&quot;.txt\&quot;)\n                        :stats    (atom {:em-ct        0\n                                         :running-mean 0\n                                         :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    (doseq [w workers]\n      (pln :spitting-to  (:out-file w) (:smtp-ip w))\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip \&quot;hunh\&quot; #_ (:smtp-ip w)}))\n\n    (pln :feeding (count workers))\n\n    (doall\n      (map (fn [worker em-rec]\n             ;(pln :out em-rec)\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (pln :start-waiting (count work-procs))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (pln :waiting-first p)\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (pln :worker-completed out :rem (count rp))\n          (recur rp))))\n\n    (println :fini)\n\n    #_ (doseq [w workers]\n         (edn-dump (:out-file w)))))&quot;, :offset 1969, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles [email-stream]\n\n  (let [emails-sent (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id       id\n                        :smtp-ip smtp-ip\n                        :ch       (chan)\n                        :sent     emails-sent\n                        :out-file (str\n                                    (:bulkmail-out-path env) \&quot;/\&quot;\n                                    smtp-ip \&quot;.txt\&quot;)\n                        :stats    (atom {:em-ct        0\n                                         :running-mean 0\n                                         :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n        \n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    (doseq [w workers]\n      (pln :spitting-to  (:out-file w) (:smtp-ip w))\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip \&quot;hunh\&quot; #_ (:smtp-ip w)}))\n\n    (pln :feeding (count workers))\n\n    (doall\n      (map (fn [worker em-rec]\n             ;(pln :out em-rec)\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (pln :start-waiting (count work-procs))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (pln :waiting-first p)\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (pln :worker-completed out :rem (count rp))\n          (recur rp))))\n\n    (println :fini)\n\n    #_ (doseq [w workers]\n         (edn-dump (:out-file w)))))&quot;, :offset 1978, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles [email-stream]\n\n  (let [emails-sent (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id       id\n                        :smtp-ip smtp-ip\n                        :ch       (chan)\n                        :sent     emails-sent\n                        :out-file (str\n                                    (:bulkmail-out-path env) \&quot;/\&quot;\n                                    smtp-ip \&quot;.txt\&quot;)\n                        :stats    (atom {:em-ct        0\n                                         :running-mean 0\n                                         :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n        \n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    (doseq [w workers]\n      (pln :spitting-to  (:out-file w) (:smtp-ip w))\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip (:smtp-ip w)}))\n\n    (pln :feeding (count workers))\n\n    (doall\n      (map (fn [worker em-rec]\n             ;(pln :out em-rec)\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (pln :start-waiting (count work-procs))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (pln :waiting-first p)\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (pln :worker-completed out :rem (count rp))\n          (recur rp))))\n\n    (println :fini)\n\n    #_ (doseq [w workers]\n         (edn-dump (:out-file w)))))&quot;, :offset 1968, :ns &quot;spamgen.core&quot;} {:command &quot;(defn emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is menaingless.\&quot;\n\n  [w task]\n\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)))\n\n        (not (running-mean-ok? w (:spam-score task)))\n        (do (pln :running-bad)\n            (:spam-score task))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (when-not (get @(:addrs-hit w) addr)\n                    (alter (:addrs-hit w) conj addr)\n                    true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          (pln :sending-to (:id w) (:email-address task))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 1606, :ns &quot;spamgen.core&quot;} {:command &quot;(defn running-mean-ok?\n  \&quot;[w (writer) new-score (score of email being considered)]\n  Decide if this new score, if included, will violate running mean score\n  invariants specified in config.edn\&quot;\n  [w new-score]\n\n  (let [stats @(:stats w)\n        running-mean (:running-mean stats)\n        new-ct (min\n                 (:running-mean-span env)\n                 (inc (:em-ct stats)))\n        new-mean (+ running-mean\n                   (/ (- new-score running-mean) new-ct))]\n    (if (&lt;= new-mean (:running-mean-max env))\n      (do\n        (swap! (:stats w) merge {:em-ct        new-ct\n                                 :running-mean new-mean})\n        true)\n      (do\n        (pln :running-mean-too-high new-mean (:running-mean stats) new-score new-ct)\n        false))))&quot;, :offset 767, :ns &quot;spamgen.core&quot;} {:command &quot;(defn running-mean-ok?\n  \&quot;[w (writer) new-score (score of email being considered)]\n  Decide if this new score, if included, will violate running mean score\n  invariants specified in config.edn\&quot;\n  [w new-score]\n\n  (let [stats @(:stats w)\n        running-mean (:running-mean stats)\n        new-ct (min\n                 (:running-mean-span env)\n                 (inc (:em-ct stats)))\n        new-mean (+ running-mean\n                   (/ (- new-score running-mean) new-ct))]\n    (when (&lt;= new-mean (:running-mean-max env))\n      (swap! (:stats w) merge {:em-ct        new-ct\n                               :running-mean new-mean})\n      true)))&quot;, :offset 642, :ns &quot;spamgen.core&quot;} {:command &quot;(defn emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)))\n\n        (not (running-mean-ok? w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (pln :running-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (when-not (get @(:addrs-hit w) addr)\n                    (alter (:addrs-hit w) conj addr)\n                    true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          #_(pln :sending-to (:id w) (:email-address task))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 1730, :ns &quot;spamgen.core&quot;} {:command &quot;(defn emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:max-overall-spam-score env)))\n\n        (not (running-mean-ok? w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (pln :running-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (when-not (get @(:addrs-hit w) addr)\n                    (alter (:addrs-hit w) conj addr)\n                    true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          #_(pln :sending-to (:id w) (:email-address task))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 1781, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-email-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2120, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (email-batch-to-sendfiles\n    (email-records-test-gen 1000 #_(:total-email-ct env))))&quot;, :offset 104, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (email-batch-to-sendfiles\n    (email-records-test-gen 10000 #_(:total-email-ct env))))&quot;, :offset 105, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (email-batch-to-sendfiles\n    (email-records-test-gen 100000 #_(:total-email-ct env))))&quot;, :offset 106, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile ; Profile any `p` forms called during body execution\n    {} ; Profiling options; we'll use the defaults for now\n    (p :send-100 (email-batch-to-sendfiles\n                (email-records-test-gen 100)))\n    (p :send-1000 (email-batch-to-sendfiles\n                    (email-records-test-gen 1000 )))\n    (p :send-10000 (email-batch-to-sendfiles\n                    (email-records-test-gen 10000)))))&quot;, :offset 426, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile ; Profile any `p` forms called during body execution\n    {} ; Profiling options; we'll use the defaults for now\n    (p :send-100 (email-batch-to-sendfiles\n                (email-records-test-gen 100)))\n    (p :send-1000 (email-batch-to-sendfiles\n                    (email-records-test-gen 1000 )))\n    (p :send-10000 (email-batch-to-sendfiles\n                    (email-records-test-gen 10000)))\n    (p :send-100000 (email-batch-to-sendfiles\n                     (email-records-test-gen 100000)))))&quot;, :offset 527, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile ; Profile any `p` forms called during body execution\n    {} ; Profiling options; we'll use the defaults for now\n    #_ (p :send-100 (email-batch-to-sendfiles\n                (email-records-test-gen 100)))\n    #_ (p :send-1000 (email-batch-to-sendfiles\n                    (email-records-test-gen 1000 )))\n    #_ (p :send-10000 (email-batch-to-sendfiles\n                    (email-records-test-gen 10000)))\n    (p :send-100000 (email-batch-to-sendfiles\n                     (email-records-test-gen 200000)))))&quot;, :offset 536, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile ; Profile any `p` forms called during body execution\n    {} ; Profiling options; we'll use the defaults for now\n    #_ (p :send-100 (email-batch-to-sendfiles\n                (email-records-test-gen 100)))\n    #_ (p :send-1000 (email-batch-to-sendfiles\n                    (email-records-test-gen 1000 )))\n    #_ (p :send-10000 (email-batch-to-sendfiles\n                    (email-records-test-gen 10000)))\n    (p :send-100000 (email-batch-to-sendfiles\n                     (email-records-test-gen 400000)))))&quot;, :offset 536, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile ; Profile any `p` forms called during body execution\n    {} ; Profiling options; we'll use the defaults for now\n    #_ (p :send-100 (email-batch-to-sendfiles\n                (email-records-test-gen 100)))\n    #_ (p :send-1000 (email-batch-to-sendfiles\n                    (email-records-test-gen 1000 )))\n    #_ (p :send-10000 (email-batch-to-sendfiles\n                    (email-records-test-gen 10000)))\n    (p :send-100000 (email-batch-to-sendfiles\n                     (email-records-test-gen 1000000)))))&quot;, :offset 537, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_ (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:max-overall-spam-score env)))\n\n        (not (running-mean-ok? w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (pln :running-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (when-not (get @(:addrs-hit w) addr)\n                    (alter (:addrs-hit w) conj addr)\n                    true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          #_(pln :sending-to (:id w) (:email-address task))\n          #_ (spit (:out-file w) task :append true))))))&quot;, :offset 1787, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile ; Profile any `p` forms called during body execution\n    {} ; Profiling options; we'll use the defaults for now\n    #_ (p :send-100 (email-batch-to-sendfiles\n                (email-records-test-gen 100)))\n    #_ (p :send-1000 (email-batch-to-sendfiles\n                    (email-records-test-gen 1000 )))\n    #_ (p :send-10000 (email-batch-to-sendfiles\n                    (email-records-test-gen 10000)))\n    (p :send-100000 (email-batch-to-sendfiles\n                     (email-records-test-gen 10000)))))&quot;, :offset 535, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_ (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:max-overall-spam-score env)))\n\n        (not (running-mean-ok? w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (pln :running-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (when-not (get @(:addrs-hit w) addr)\n                    (alter (:addrs-hit w) conj addr)\n                    true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          #_(pln :sending-to (:id w) (:email-address task))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 1784, :ns &quot;spamgen.core&quot;} {:command &quot;(defn emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_ (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:max-overall-spam-score env)))\n\n        ;;(not (running-mean-ok? w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        ;;(do (pln :running-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (when-not (get @(:addrs-hit w) addr)\n                    (alter (:addrs-hit w) conj addr)\n                    true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          #_(pln :sending-to (:id w) (:email-address task))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 1788, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile ; Profile any `p` forms called during body execution\n    {} ; Profiling options; we'll use the defaults for now\n    #_ (p :send-100 (email-batch-to-sendfiles\n                (email-records-test-gen 100)))\n    #_ (p :send-1000 (email-batch-to-sendfiles\n                    (email-records-test-gen 1000 )))\n    #_ (p :send-10000 (email-batch-to-sendfiles\n                    (email-records-test-gen 10000)))\n    (p :send-100000 (email-batch-to-sendfiles\n                     (email-records-test-gen 100000)))))&quot;, :offset 536, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (cond\n    (&gt; (:spam-score task) (:max-individual-spam-score env))\n    (do #_(pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:score-sum stats))\n          new-ct (inc (:em-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:max-overall-spam-score env))\n        (do #_ (pln :overall-email-mean-bad :w (:id w) :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:max-overall-spam-score env)))\n\n        ;;(not (running-mean-ok? w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        ;;(do (pln :running-mean-bad (:spam-score task)))\n\n        :default\n        (when true #_ (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (when-not (get @(:addrs-hit w) addr)\n                    (alter (:addrs-hit w) conj addr)\n                    true)))\n          (swap! (:stats w) merge {:em-ct     new-ct\n                                   :score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually\n          #_(pln :sending-to (:id w) (:email-address task))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 1796, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-email-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         p\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2123, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile ; Profile any `p` forms called during body execution\n    {} ; Profiling options; we'll use the defaults for now\n    #_ (p :send-100 (email-batch-to-sendfiles\n                (email-records-test-gen 100)))\n    #_ (p :send-1000 (email-batch-to-sendfiles\n                    (email-records-test-gen 1000 )))\n    #_ (p :send-10000 (email-batch-to-sendfiles\n                    (email-records-test-gen 10000)))\n    (p :send-100000 (email-batch-to-sendfiles\n                     (email-records-test-gen 50000)))))&quot;, :offset 535, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (emw-email-consider w task)\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2122, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  (p :consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p &amp; rp :as ps] work-procs]\n      (when p\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2136, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2142, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (p :spit-init\n      (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)})))\n\n    (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2163, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile                                                  ; Profile any `p` forms called during body execution\n    {:dynamic? true}                                                      ; Profiling options; we'll use the defaults for now\n    #_(p :send-100 (email-batch-to-sendfiles\n                     (email-records-test-gen 100)))\n    #_(p :send-1000 (email-batch-to-sendfiles\n                      (email-records-test-gen 1000)))\n    #_(p :send-10000 (email-batch-to-sendfiles\n                       (email-records-test-gen 10000)))\n    (p ::send-100000\n      (email-batch-to-sendfiles\n        (email-records-test-gen 5000)))))&quot;, :offset 650, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile                                                  ; Profile any `p` forms called during body execution\n    {:dynamic? true}                                                      ; Profiling options; we'll use the defaults for now\n    #_(p :send-100 (email-batch-to-sendfiles\n                     (email-records-test-gen 100)))\n    #_(p :send-1000 (email-batch-to-sendfiles\n                      (email-records-test-gen 1000)))\n    #_(p :send-10000 (email-batch-to-sendfiles\n                       (email-records-test-gen 10000)))\n    (p ::send-100000\n      (email-batch-to-sendfiles\n        (email-records-test-gen 50000)))))&quot;, :offset 651, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                   ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (p :spit-init\n      (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)})))\n\n    (p :feed-workers\n      (dorun\n      (map (fn [worker em-rec]\n             (&gt;!! (:ch worker) em-rec))\n        (cycle workers)\n        email-stream)))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2187, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          (partition-all 100 email-stream))))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2191, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest devtest\n  (profile                                                  ; Profile any `p` forms called during body execution\n    {:dynamic? true}                                                      ; Profiling options; we'll use the defaults for now\n    #_(p :send-100 (email-batch-to-sendfiles\n                     (email-records-test-gen 100)))\n    #_(p :send-1000 (email-batch-to-sendfiles\n                      (email-records-test-gen 1000)))\n    #_(p :send-10000 (email-batch-to-sendfiles\n                       (email-records-test-gen 10000)))\n    (p ::send-100000\n      (email-batch-to-sendfiles\n        (email-records-test-gen 500000)))))&quot;, :offset 652, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em100.txt\&quot; (email-records-test-gen 100))&quot;, :offset 57, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em100x.txt\&quot; (doall (email-records-test-gen 100)))&quot;, :offset 66, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em100.txt\&quot; (doall (email-records-test-gen 100)))&quot;, :offset 65, :ns &quot;spamgen.core-test&quot;} {:command &quot;(count (slurp \&quot;bulkinput/em100.txt\&quot;))&quot;, :offset 37, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn edn-load [path]\n   (with-open [in (java.io.PushbackReader. (clojure.java.io/reader path))]\n     (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n       (take-while (partial not= :fini) edn-seq))))&quot;, :offset 216, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em10.txt\&quot; (vec (email-records-test-gen 10)))&quot;, :offset 61, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn edn-load [path]\n   (with-open [in (java.io.PushbackReader. (clojure.java.io/reader path))]\n     (edn/read in)\n     #_\n     (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n       (take-while (partial not= :fini) edn-seq))))&quot;, :offset 243, :ns &quot;spamgen.core-test&quot;} {:command &quot;(edn-load \&quot;bulkinput/em100.txt\&quot;)&quot;, :offset 32, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em100.txt\&quot; (vec (email-records-test-gen 100)))&quot;, :offset 63, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em1000.txt\&quot; (vec (email-records-test-gen 1000)))&quot;, :offset 65, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em10000.txt\&quot; (vec (email-records-test-gen 10000)))&quot;, :offset 67, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit \&quot;bulkinput/em100000.txt\&quot; (vec (email-records-test-gen 100000)))&quot;, :offset 69, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn bulk-input-build [prefix em-count]\n  (let [bf (str \&quot;bulkinput/\&quot; prefix \&quot;-\&quot; em-count \&quot;.edn\&quot;)]\n    (spit bf {:build-date (.toString (java.util.Date.))\n              :count em-count})\n    (doseq [em (email-records-test-gen em-count)]\n      (spit bf em :append true))))&quot;, :offset 271, :ns &quot;spamgen.core-test&quot;} {:command &quot;(bulk-input-build \&quot;emf\&quot; 10)&quot;, :offset 27, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn bulk-input-sequence [path]\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader path))]\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (take-while (partial not= :fini) edn-seq))))&quot;, :offset 224, :ns &quot;spamgen.core&quot;} {:command &quot;(first (bulk-input-sequence \&quot;emf-10.edn\&quot;))&quot;, :offset 42, :ns &quot;spamgen.core&quot;} {:command &quot;(first (bulk-input-sequence \&quot;bulkinput/emf-10.edn\&quot;))&quot;, :offset 52, :ns &quot;spamgen.core&quot;} {:command &quot;(defn bulk-input-sequence [path handler]\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader path))]\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (dorun (map handler (take-while (partial not= :fini) edn-seq))))))&quot;, :offset 254, :ns &quot;spamgen.core&quot;} {:command &quot;(bulk-input-sequence \&quot;bulkinput/emf-10.edn\&quot; println)&quot;, :offset 52, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest infile-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader path))]\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (email-batch-to-sendfiles edn-seq))))&quot;, :offset 204, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest infile-edn\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-10.edn\&quot;))]\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (email-batch-to-sendfiles edn-seq))))&quot;, :offset 222, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest infile-edn\n  (pln :startedn)\n  (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/emf-10.edn\&quot;))]\n    (pln :ednin in)\n    (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n      (pln :eseq edn-seq)\n      (email-batch-to-sendfiles edn-seq))))&quot;, :offset 286, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n  (pln :stream! email-stream (first email-stream))\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2222, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-batch-to-sendfiles\n  \&quot;[email-stream (coll)] Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream]\n  (pln :stream! email-stream (first email-stream))\n\n  (let [em-addrs-hit (ref #{})\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        (chan 10)                ;; todo try buffering\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env) \&quot;/\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:em-ct        0\n                                          :running-mean 0\n                                          :score-sum    0})})\n                  (range)\n                  (take (min (count (:smtp env))\n                          (:worker-ct env))\n                    (:smtp env)))\n\n        work-procs (dorun\n                     (map (fn [w]\n                            (go-loop []\n                              (if-let [task (&lt;! (:ch w))]\n                                (do\n                                  ;;(p ::consider (emw-email-consider w task))\n                                  (recur))\n                                [:fini (:id w)])))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (dorun\n        (map (fn [worker em-rec]\n               (pln :do-em em-rec)\n               (&gt;!! (:ch worker) em-rec))\n          (cycle workers)\n          email-stream)))\n\n    (loop [[p1 &amp; rp :as ps] work-procs]\n      (when p1\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         p1\n                         ([r] r))]\n          (recur rp))))\n\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2257, :ns &quot;spamgen.core&quot;} {:command &quot;(defn -main [&amp; args]\n  ;; #_ ;; uncomment during development so errors get through when async in play\n      (Thread/setDefaultUncaughtExceptionHandler\n        (reify Thread$UncaughtExceptionHandler\n          (uncaughtException [_ thread ex]\n            (log/error {:what :uncaught-exception\n                        :exception ex\n                        :where (str \&quot;Uncaught exception on\&quot; (.getName thread))}))))\n\n  (let [input (parse-opts args times-cli)\n        {:keys [options arguments summary errors]} input\n        {:keys [width spacing test help]} options\n        built-ins (let [known (vec (rest (file-seq\n                                           (clojure.java.io/file \&quot;./resources\&quot;))))]\n                    (when (&gt; test (count known))\n                      (println (format \&quot;\\nWarning: only %d test files exist in ./resources\\n\\n\&quot;\n                                 (count known))))\n                    (map #(.getPath %)\n                      (subvec known 0 (min test (count known)))))\n        filepaths (concat arguments built-ins)]\n\n    (cond\n      errors (doseq [e errors]\n               (println e))\n\n      help (println \&quot;\\nUsage:\\n\\n    concurtimes options* files*\\n\\n\&quot;\n             \&quot;Options:\\n\&quot; (subs summary 1))\n\n      :default (do\n                 #_ (email-batch-to-sendfiles &lt;tbd&gt;)\n                 (pln :fnyi))\n      ))\n\n  ;; WARNING: comment this out for use with REPL\n  ;;(shutdown-agents)\n  )&quot;, :offset 1418, :ns &quot;spamgen.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.main">
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
    <configuration name="main" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="1" />
      <module name="spamgen" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="" />
      <created>1521628166875</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1521628166875</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="93" y="67" width="1494" height="886" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.4386852" sideWeight="0.5" order="10" side_tool="true" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.14257029" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
    </layout>
    <layout-to-restore>
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.32931727" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="false" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.14257029" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
    </layout-to-restore>
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager />
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="153">
          <caret line="9" column="0" lean-forward="false" selection-start-line="9" selection-start-column="0" selection-end-line="9" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="17">
          <caret line="1" column="0" lean-forward="true" selection-start-line="1" selection-start-column="0" selection-end-line="1" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="18" lean-forward="true" selection-start-line="7" selection-start-column="18" selection-end-line="7" selection-end-column="18" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="249">
          <caret line="3207" column="10" lean-forward="false" selection-start-line="3207" selection-start-column="10" selection-end-line="3207" selection-end-column="10" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="452">
          <caret line="47" column="41" lean-forward="false" selection-start-line="47" selection-start-column="41" selection-end-line="47" selection-end-column="41" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/config/dev/config.edn">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="170">
          <caret line="10" column="2" lean-forward="false" selection-start-line="10" selection-start-column="2" selection-end-line="10" selection-end-column="2" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="144">
          <caret line="9" column="46" lean-forward="false" selection-start-line="9" selection-start-column="46" selection-end-line="9" selection-end-column="46" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="315">
          <caret line="29" column="22" lean-forward="true" selection-start-line="29" selection-start-column="22" selection-end-line="29" selection-end-column="22" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="23">
          <caret line="28" column="43" lean-forward="false" selection-start-line="28" selection-start-column="43" selection-end-line="28" selection-end-column="43" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>