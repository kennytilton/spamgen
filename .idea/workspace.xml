<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="">
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/src/spamgen/core.clj" afterPath="$PROJECT_DIR$/src/spamgen/core.clj" />
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/test/spamgen/core_test.clj" afterPath="$PROJECT_DIR$/test/spamgen/core_test.clj" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="project.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="357">
              <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core_test.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="318">
              <caret line="129" column="33" lean-forward="true" selection-start-line="129" selection-start-column="33" selection-end-line="129" selection-end-column="33" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.clj" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="240">
              <caret line="122" column="34" lean-forward="false" selection-start-line="122" selection-start-column="34" selection-end-line="122" selection-end-column="34" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>test-email-records</find>
      <find>println</find>
      <find>:sent</find>
      <find>env</find>
      <find>running-mean-ok?</find>
      <find>running-mean</find>
      <find>:rejected-span-mean</find>
      <find>:rejected-last-n</find>
      <find>:last-n-mean</find>
      <find>span-mean</find>
      <find>:max-overall-spam-score</find>
      <find>:overall-mean-max</find>
      <find>:individual-max</find>
      <find>:score-sum</find>
      <find>:total-email-ct</find>
      <find>:rejected-</find>
      <find>:max-individual-spam-score</find>
      <find>RV</find>
      <find>rejected-abs</find>
      <find>em-ct</find>
      <find>out-file</find>
      <find>spitter</find>
      <find>slices</find>
    </findStrings>
    <replaceStrings>
      <replace>em-addrs-hit</replace>
      <replace>:addrs-hit</replace>
      <replace>*env*</replace>
      <replace>span-mean-ok</replace>
      <replace>:rejected-span-mean</replace>
      <replace>last-n-mean</replace>
      <replace>last-n-span</replace>
      <replace>env-hack</replace>
      <replace>:span-mean</replace>
      <replace>last-n</replace>
      <replace>:overall-mean-max</replace>
      <replace>:spam-score-sum</replace>
      <replace>:individual-max</replace>
      <replace>XXX</replace>
      <replace>RV</replace>
      <replace>:rejected-overall-mean</replace>
      <replace>XX</replace>
      <replace>rejected-score</replace>
      <replace>sent-ct</replace>
      <replace>scores</replace>
      <replace>spit-file</replace>
      <replace>board</replace>
    </replaceStrings>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/resources/config.edn" />
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/config/dev/config.edn" />
        <option value="$PROJECT_DIR$/src/spamgen/genlist.clj" />
        <option value="$PROJECT_DIR$/test/spamgen/core_test.clj" />
        <option value="$PROJECT_DIR$/src/spamgen/core.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds">
    <option name="x" value="93" />
    <option name="y" value="68" />
    <option name="width" value="1425" />
    <option name="height" value="886" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="AndroidView" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
              <item name="dev" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="Scope" />
      <pane id="PackagesPane" />
      <pane id="Scratches" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="configurable.group.build" />
    <property name="cursive.last.file.extension./Users/kennethtilton/spamgen/src" value="clj" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/config/dev" />
    </key>
  </component>
  <component name="ReplState" timestamp="1521925715856">{:repl-history {:ide [], :local [{:command &quot;(defn no-can-dart\n  \&quot;Given a nmber of darts and the scores available on a dartboard, return\n  the lowest total score that cannot be scored. e.g., with one dart and\n  scores 1 and 3, we cannot score two. Withe two darts we cannot score 5.\&quot;\n  [dart-ct dartboard-scores]\n\n  (let [scores (sort (distinct dartboard-scores))           ;; short for normalized scores\n        gapless (atom 0)]                                   ;; short for gapless max score observed as we traverse possible scoring combos\n    (cond\n      (&gt; (first scores) 1)\n      1\n\n      (= dartboard-scores (range 1 (inc (count dartboard-scores))))\n      (inc (* dart-ct (last scores)))\n\n      :default\n      (letfn [(next-in-order []\n                (inc @gapless))\n              (throw-dart [dart-no score-so-far]\n                (when (pos? dart-no)\n                  (loop [[throw-score &amp; rthrows] scores]\n                    (when throw-score\n                      (let [new-total (+ score-so-far throw-score)]\n                        ;; we could pull the recursive call here since all branches of the cond\n                        ;; invoke it, but methinks that borders on obfuscation\n                        (cond\n                          (= new-total (next-in-order))\n                          (do\n                            (swap! gapless inc)\n                            ;; we keep going as an efficiency: if the next slice is one more\n                            ;; than the current slice, we can bump our gapless value straight away,\n                            ;; effectively pruning further searching.\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))\n\n                          (&gt; new-total (next-in-order))\n                          ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                          ;; and try the next, if any, which will possibly have access to lower values.\n                          (throw-dart (dec dart-no) new-total)\n\n                          :default                          ;; ie, new-total too low\n                          ;; try next dart if any and keep trying this dart\n                          (do\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))))))))]\n        (throw-dart dart-ct 0)\n        (next-in-order)))))&quot;, :offset 2385, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart\n  \&quot;Given a nmber of darts and the scores available on a dartboard, return\n  the lowest total score that cannot be scored. e.g., with one dart and\n  scores 1 and 3, we cannot score two. Withe two darts we cannot score 5.\&quot;\n  [dart-ct dartboard-scores]\n\n  (let [scores (sort (distinct dartboard-scores))           ;; short for normalized scores\n        gapless (atom 0)]                                   ;; short for gapless max score observed as we traverse possible scoring combos\n    (cond\n      ;;; nail a couple of special cases\n      (or\n          (not (pos? dart-ct))\n          (empty? dartboard-scores)\n          (&gt; (first scores) 1))\n      1\n\n      ;; this one actually spares us a full sweep\n      (= dartboard-scores (range 1 (inc (count dartboard-scores))))\n      (inc (* dart-ct (last scores)))\n\n      :default\n      (letfn [(next-in-order []\n                (inc @gapless))\n              (throw-dart [dart-no score-so-far]\n                (when (pos? dart-no)\n                  (loop [[throw-score &amp; rthrows] scores]\n                    (when throw-score\n                      (let [new-total (+ score-so-far throw-score)]\n                        ;; we could pull the recursive call here since all branches of the cond\n                        ;; invoke it, but methinks that borders on obfuscation\n                        (cond\n                          (= new-total (next-in-order))\n                          (do\n                            (swap! gapless inc)\n                            ;; we keep going as an efficiency: if the next slice is one more\n                            ;; than the current slice, we can bump our gapless value straight away,\n                            ;; effectively pruning further searching.\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))\n\n                          (&gt; new-total (next-in-order))\n                          ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                          ;; and try the next, if any, which will possibly have access to lower values.\n                          (throw-dart (dec dart-no) new-total)\n\n                          :default                          ;; ie, new-total too low\n                          ;; try next dart if any and keep trying this dart\n                          (do\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))))))))]\n        (throw-dart dart-ct 0)\n        (next-in-order)))))&quot;, :offset 2558, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest darts\n  (let [board nil]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 1 (no-can-dart -1 board)))\n    (is (= 1 (no-can-dart 10 board))))\n  (let [board [2 3 4]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 1 (no-can-dart 1 board)))\n    (is (= 1 (no-can-dart 10 board))))\n  (let [board [1 2 3 4]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 5 (no-can-dart 1 board)))\n    (is (= 9 (no-can-dart 2 board))))\n  (let [board [1 3]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 2 (no-can-dart 1 board)))\n    (is (= 5 (no-can-dart 2 board)))\n    (is (= 8 (no-can-dart 3 board))))\n  (let [board [1 3 7]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 2 (no-can-dart 1 board)))\n    (is (= 5 (no-can-dart 2 board)))\n    (is (= 12 (no-can-dart 3 board))))\n  (let [board [1 4 7]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 2 (no-can-dart 1 board)))\n    (is (= 3 (no-can-dart 2 board)))\n    (is (= 10 (no-can-dart 3 board))))\n  (let [board [1 2 5 6]]\n    (is (= 1 (no-can-dart 0 board)))\n    (is (= 3 (no-can-dart 1 board)))\n    (is (= 9 (no-can-dart 2 board)))\n    (is (= 15 (no-can-dart 3 board)))))&quot;, :offset 1112, :ns &quot;spamgen.core-test&quot;} {:command &quot;#(no-can-dart [-2 -3 -7] 1)&quot;, :offset 27, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn no-can-dart\n  \&quot;Given a nmber of darts and the scores available on a dartboard, return\n  the lowest total score that cannot be scored. e.g., with one dart and\n  scores 1 and 3, we cannot score two. Withe two darts we cannot score 5.\n\n  Assumes scores are positive.\&quot;\n  [dart-ct dartboard-scores]\n\n  (let [scores (sort (distinct dartboard-scores))           ;; short for normalized scores\n        gapless (atom 0)]                                   ;; short for gapless max score observed as we traverse possible scoring combos\n    (cond\n      ;;; nail a couple of special cases\n      (or\n        (not (pos? dart-ct))\n        (empty? dartboard-scores)\n        (&gt; (first scores) 1))\n      1\n\n      ;; this one actually spares us a full sweep\n      (= dartboard-scores (range 1 (inc (count dartboard-scores))))\n      (inc (* dart-ct (last scores)))\n\n      :default\n      (letfn [(next-in-order []\n                (inc @gapless))\n              (throw-dart [dart-no score-so-far]\n                (when (pos? dart-no)\n                  (loop [[throw-score &amp; rthrows] scores]\n                    (when throw-score\n                      (let [new-total (+ score-so-far throw-score)]\n                        ;; we could pull the recursive call here since all branches of the cond\n                        ;; invoke it, but methinks that borders on obfuscation\n                        (cond\n                          (= new-total (next-in-order))\n                          (do\n                            (swap! gapless inc)\n                            ;; we keep going as an efficiency: if the next slice is one more\n                            ;; than the current slice, we can bump our gapless value straight away,\n                            ;; effectively pruning further searching.\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))\n\n                          (&gt; new-total (next-in-order))\n                          ;; rthrows, being sorted, contains only higher values, so abandon this dart\n                          ;; and try the next, if any, which will possibly have access to lower values.\n                          (throw-dart (dec dart-no) new-total)\n\n                          :default                          ;; ie, new-total too low\n                          ;; try next dart if any and keep trying this dart\n                          (do\n                            (throw-dart (dec dart-no) new-total)\n                            (recur rthrows))))))))]\n        (throw-dart dart-ct 0)\n        (next-in-order)))))&quot;, :offset 2584, :ns &quot;spamgen.core-test&quot;} {:command &quot;(count (email-records-test-gen 100000))&quot;, :offset 39, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-count\n   (p :test-gen-count\n     (count (email-records-test-gen 100000))))&quot;, :offset 92, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-count\n  (profile\n    {:dynamic? true}\n    (p :test-gen-count\n      (count (email-records-test-gen 100000))))\n   )&quot;, :offset 131, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-apit\n  (profile\n    {:dynamic? true}\n    (p :test-gen-count\n      (spit \&quot;testgen\&quot;(email-records-test-gen 100000)))))&quot;, :offset 134, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-apit\n  (profile\n    {:dynamic? true}\n    (p :test-gen-count\n      (spit \&quot;testgen.edn\&quot;\n        (into [] (email-records-test-gen 100000))))))&quot;, :offset 157, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-slurp\n  (profile\n    {:dynamic? true}\n    (p :test-gen-count\n      (slurp \&quot;testgen.edn\&quot;))))&quot;, :offset 109, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest test-gen-count\n  (profile\n    {:dynamic? true}\n    (p :test-gen-count\n      (let [test (email-records-test-gen 10000)]\n        (pln :testing!)\n        (count test))\n      )))&quot;, :offset 183, :ns &quot;spamgen.core-test&quot;} {:command &quot;(s/def ::email-record\n  (s/keys :req-un [::email-address ::email-body ::spam-score]))&quot;, :offset 85, :ns &quot;spamgen.genlist&quot;} {:command &quot;(s/def ::email-record\n  (s/keys :req-un [::email-address  ::spam-score]))&quot;, :offset 73, :ns &quot;spamgen.genlist&quot;} {:command &quot;(spit (str \&quot;bulkinput/\&quot; 1000) (email-records-test-gen 1000))&quot;, :offset 60, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit (str \&quot;bulkinput/em-\&quot; 1000) (email-records-test-gen 1000))&quot;, :offset 63, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit (str \&quot;bulkinput/em-\&quot; 1000)\n      (into [] (email-records-test-gen 1000)))&quot;, :offset 79, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest devtest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-stream-to-sendfiles-mp\n        (email-records-test-gen 100000)\n        false)))\n  (pln :devtest-fini))&quot;, :offset 183, :ns &quot;spamgen.core-test&quot;} {:command &quot;(spit (str \&quot;bulkinput/em-\&quot; 1000 \&quot;.edn\&quot;)\n      (into [] (email-records-test-gen 1000)))&quot;, :offset 86, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [n 10]\n    (spit (str \&quot;bulkinput/em-\&quot; n \&quot;.edn\&quot;)\n      (into [] (email-records-test-gen n))))&quot;, :offset 97, :ns &quot;spamgen.core-test&quot;} {:command &quot;(slurp \&quot;bulkinput/em-1000.edn\&quot;)&quot;, :offset 31, :ns &quot;spamgen.core-test&quot;} {:command &quot;(edn/read-string\n  (slurp \&quot;bulkinput/em-1000.edn\&quot;))&quot;, :offset 51, :ns &quot;spamgen.core-test&quot;} {:command &quot;(first (edn/read-string\n         (slurp \&quot;bulkinput/em-1000.edn\&quot;)))&quot;, :offset 66, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3       \n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; n \&quot;.edn\&quot;) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 282, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3\n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; n \&quot;.edn\&quot;)\n               {:append (pos? n)}))\n        (range)\n        chunks))))&quot;, :offset 292, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3\n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               {:append (pos? n)}))\n        (range)\n        chunks))))&quot;, :offset 296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3\n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               c {:append (pos? n)}))\n        (range)\n        chunks))))&quot;, :offset 298, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3\n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               c :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 3\n      total 12]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))\n        append (atom false)]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 306, :ns &quot;spamgen.core-test&quot;} {:command &quot;(with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/em-1000.edn\&quot;))]\n  (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n    (dorun (map println (take-while (partial not= :fini) edn-seq)))))&quot;, :offset 225, :ns &quot;spamgen.core-test&quot;} {:command &quot;(with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/em-1000.edn\&quot;))]\n  (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n    (doseq [chunk (take-while (partial not= :fini) edn-seq)]\n      (pln :chk chunk))))&quot;, :offset 242, :ns &quot;spamgen.core-test&quot;} {:command &quot;(with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/em-12.edn\&quot;))]\n  (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n    (doseq [chunk (take-while (partial not= :fini) edn-seq)]\n      (pln :chk chunk))))&quot;, :offset 240, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/em-12.edn\&quot;))]\n      (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n        (doseq [chunk (take-while (partial not= :fini) edn-seq)]\n          (doseq [em chunk]\n          (&gt;!! shared-chan em)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3014, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (with-open [in (java.io.PushbackReader. (clojure.java.io/reader \&quot;bulkinput/em-12.edn\&quot;))]\n      (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n        (doseq [chunk (take-while (partial not= :fini) edn-seq)]\n          (doseq [em chunk]\n            (&gt;!! shared-chan em)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3016, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [task (&lt;! (:ch w))]\n                                (emw-email-consider w task)\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n      (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n        (doseq [chunk (take-while (partial not= :fini) edn-seq)]\n          (doseq [em chunk]\n            (pln :send-top em)\n            (&gt;!! shared-chan em)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3023, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  ;;(pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2240, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (pln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (pln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (pln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2238, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 20\n      total 1000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 281, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-1000.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 175, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn xpln [&amp; args])&quot;, :offset 20, :ns &quot;spamgen.core&quot;} {:command &quot;(declare pln xpln email-stream-to-sendfiles-mp)&quot;, :offset 47, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-stream-to-sendfiles-mp\n  \&quot;[email-stream (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [email-stream verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 1000)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [chunk (&lt;! (:ch w))]\n                                (doseq [task chunk]\n                                  (emw-email-consider w task))\n                                \n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (doseq [em email-stream]\n      (&gt;!! shared-chan em))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 2873, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n      (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n        (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n          (&gt;!! shared-chan em-chunk))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3028, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task)(:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n                :new-mean (/ new-sum new-ct)\n                :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2241, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 20\n      total 10000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 282, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p: (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3045, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3064, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 20\n      total 100000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 283, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 20\n      total 100000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 294, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 1000\n      total 100000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-100000-10000.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 183, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 10000\n      total 100000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 297, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 10000\n      total 1000000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 298, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 100\n      total 10000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 298, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 100\n      total 100000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 299, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 100\n      total 1000000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 300, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-1000000-100.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 182, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 1000\n      total 1000000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 301, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-1000000-1000.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 183, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-100000-1000.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 182, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-100000-100.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 181, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          #_ (spit (:out-file w) task :append true))))))&quot;, :offset 2241, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2238, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          #_(spit (:out-file w) task :append true))))))&quot;, :offset 2240, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file  (str\n                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                     smtp-ip \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3092, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file (str\n                    (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                    smtp-ip \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit file with a header ----------------------\n\n    (spit spit-file\n      {:run-date (.toString (java.util.Date.))\n       :smtp-ip  (:smtp-ip w)})\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [em (&lt;! spit-chan)]\n          (spit spit-file em :append true))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n    \n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n    \n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3441, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n          \n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (&gt;!! task (:spit-chan w)))))))&quot;, :offset 2170, :ns &quot;spamgen.core&quot;} {:command &quot;(.toString (java.util.Date.))&quot;, :offset 29, :ns &quot;spamgen.core&quot;} {:command &quot;(java.util.Date.)&quot;, :offset 17, :ns &quot;spamgen.core&quot;} {:command &quot;(quot (System/currentTimeMillis) 1000)&quot;, :offset 38, :ns &quot;spamgen.core&quot;} {:command &quot;(System/currentTimeMillis)&quot;, :offset 26, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file (str\n                    (:bulkmail-out-path env-hack) \n                    \&quot;/em-\&quot; (System/currentTimeMillis) \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit file with a header ----------------------\n\n    (spit spit-file\n      {:run-date (.toString (java.util.Date.))\n       :smtp-ip  (:smtp-ip w)})\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [em (&lt;! spit-chan)]\n          (spit spit-file em :append true))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3453, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file (str\n                    (:bulkmail-out-path env-hack)\n                    \&quot;/em-\&quot; (System/currentTimeMillis) \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit file with a header ----------------------\n\n    (spit spit-file\n      {:run-date (.toString (java.util.Date.))\n       :smtp-ip  (:smtp-ip w)})\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [em (&lt;! spit-chan)]\n          (spit spit-file em :append true))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3619, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true)))\n          (&gt;!! [(:spit-file w) task] (:spit-chan w)))))&quot;, :offset 2226, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          ;; (spit (:out-file w) task :append true)))\n          (&gt;!! [(:spit-file w) task] (:spit-chan w)))))))&quot;, :offset 2231, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          ;; (spit (:out-file w) task :append true)))\n          (go (&gt;! [(:spit-file w) task] (:spit-chan w))))))))&quot;, :offset 2235, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          ;; (spit (:spit-file w) task :append true)))\n          (go (&gt;! (:spit-chan w)\n                [(:spit-file w) task])))))))&quot;, :offset 2252, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (pln :sending-to (:spit-chan w) [(:spit-file w) task])\n          ;; (spit (:spit-file w) task :append true)))\n          #_\n          (&gt;! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2225, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file (str\n                    (:bulkmail-out-path env-hack)\n                    \&quot;/em-\&quot; (System/currentTimeMillis) \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [x (&lt;! spit-chan)]\n          (when x\n            (let [[spit-file em] x]\n              (spit spit-file em :append true))))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3715, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file (str\n                    (:bulkmail-out-path env-hack)\n                    \&quot;/em-\&quot; (System/currentTimeMillis) \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [x (&lt;! spit-chan)]\n          (let [[spit-file em] x]\n            (spit spit-file em :append true)))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3692, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 10\n      total 50]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 294, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-50-10.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 176, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (pln :sending-to (:spit-chan w) [(:spit-file w) task])\n          ;; (spit (:spit-file w) task :append true)))\n          \n          (&gt;! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2223, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [x (&lt;! spit-chan)]\n          (let [[spit-file em] x]\n            (pln :sptting spit-file em)\n            (spit spit-file em :append true)))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3597, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (pln :sending-to (:spit-chan w) [(:spit-file w) task])\n          ;; (spit (:spit-file w) task :append true)))\n\n          (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2214, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-10000-100.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 180, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 50\n      total 1000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-1000-50.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 178, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-100-20.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 177, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan   spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [x (&lt;! spit-chan)]\n          (pln :xx x)\n          (let [[spit-file em] x]\n            (pln :sptting spit-file em)\n            (spit spit-file em :append true)))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3617, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 20\n      total 100]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 295, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :xx x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (recur rest))))\n\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 3921, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :xx x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (recur rest))))\n\n      ;; waiting on spitter\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 3949, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :xx x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 3995, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :xx x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4026, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-200-20.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 177, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 20\n      total 200]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 295, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk)\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :xx x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4075, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :got-spit x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4098, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :got-spit x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)\n                          (recur)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4132, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :got-spit x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)\n                          (recur)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 1000) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 1000) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4134, :ns &quot;spamgen.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.main">
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
    <configuration name="main" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="1" />
      <module name="spamgen" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="" />
      <created>1521628166875</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1521628166875</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="93" y="68" width="1425" height="886" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.49473685" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.13912475" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
    </layout>
    <layout-to-restore>
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.3435663" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.13912475" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
    </layout-to-restore>
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/test/spamgen/core_test.clj</url>
          <line>9</line>
          <properties />
          <option name="timeStamp" value="1" />
        </line-breakpoint>
      </breakpoints>
      <option name="time" value="10" />
    </breakpoint-manager>
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="153">
          <caret line="9" column="0" lean-forward="false" selection-start-line="9" selection-start-column="0" selection-end-line="9" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="17">
          <caret line="1" column="0" lean-forward="true" selection-start-line="1" selection-start-column="0" selection-end-line="1" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="18" lean-forward="true" selection-start-line="7" selection-start-column="18" selection-end-line="7" selection-end-column="18" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="249">
          <caret line="3207" column="10" lean-forward="false" selection-start-line="3207" selection-start-column="10" selection-end-line="3207" selection-end-column="10" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="357">
          <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/config/dev/config.edn">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="13" lean-forward="false" selection-start-line="7" selection-start-column="1" selection-end-line="7" selection-end-column="13" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="276">
          <caret line="40" column="17" lean-forward="true" selection-start-line="40" selection-start-column="17" selection-end-line="40" selection-end-column="17" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="318">
          <caret line="129" column="33" lean-forward="true" selection-start-line="129" selection-start-column="33" selection-end-line="129" selection-end-column="33" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="240">
          <caret line="122" column="34" lean-forward="false" selection-start-line="122" selection-start-column="34" selection-end-line="122" selection-end-column="34" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>