<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="">
      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/src/spamgen/core.clj" afterPath="$PROJECT_DIR$/src/spamgen/core.clj" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="project.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="357">
              <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core_test.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="409">
              <caret line="129" column="33" lean-forward="true" selection-start-line="129" selection-start-column="33" selection-end-line="129" selection-end-column="33" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.clj" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="381">
              <caret line="251" column="41" lean-forward="true" selection-start-line="251" selection-start-column="41" selection-end-line="251" selection-end-column="41" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>test-email-records</find>
      <find>println</find>
      <find>:sent</find>
      <find>env</find>
      <find>running-mean-ok?</find>
      <find>running-mean</find>
      <find>:rejected-span-mean</find>
      <find>:rejected-last-n</find>
      <find>:last-n-mean</find>
      <find>span-mean</find>
      <find>:max-overall-spam-score</find>
      <find>:overall-mean-max</find>
      <find>:individual-max</find>
      <find>:score-sum</find>
      <find>:total-email-ct</find>
      <find>:rejected-</find>
      <find>:max-individual-spam-score</find>
      <find>RV</find>
      <find>rejected-abs</find>
      <find>em-ct</find>
      <find>out-file</find>
      <find>spitter</find>
      <find>slices</find>
      <find>got</find>
    </findStrings>
    <replaceStrings>
      <replace>em-addrs-hit</replace>
      <replace>:addrs-hit</replace>
      <replace>*env*</replace>
      <replace>span-mean-ok</replace>
      <replace>:rejected-span-mean</replace>
      <replace>last-n-mean</replace>
      <replace>last-n-span</replace>
      <replace>env-hack</replace>
      <replace>:span-mean</replace>
      <replace>last-n</replace>
      <replace>:overall-mean-max</replace>
      <replace>:spam-score-sum</replace>
      <replace>:individual-max</replace>
      <replace>XXX</replace>
      <replace>RV</replace>
      <replace>:rejected-overall-mean</replace>
      <replace>XX</replace>
      <replace>rejected-score</replace>
      <replace>sent-ct</replace>
      <replace>scores</replace>
      <replace>board</replace>
      <replace>spit-file</replace>
    </replaceStrings>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/resources/config.edn" />
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/config/dev/config.edn" />
        <option value="$PROJECT_DIR$/src/spamgen/genlist.clj" />
        <option value="$PROJECT_DIR$/test/spamgen/core_test.clj" />
        <option value="$PROJECT_DIR$/src/spamgen/core.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds">
    <option name="x" value="93" />
    <option name="y" value="68" />
    <option name="width" value="1544" />
    <option name="height" value="886" />
  </component>
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="AndroidView" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="config" type="462c0819:PsiDirectoryNode" />
              <item name="dev" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="spamgen" type="b2602c69:ProjectViewProjectNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
              <item name="test" type="462c0819:PsiDirectoryNode" />
              <item name="spamgen" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="Scope" />
      <pane id="PackagesPane" />
      <pane id="Scratches" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="configurable.group.build" />
    <property name="cursive.last.file.extension./Users/kennethtilton/spamgen/src" value="clj" />
  </component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/config/dev" />
    </key>
  </component>
  <component name="ReplState" timestamp="1521941829555">{:repl-history {:ide [], :local [{:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3064, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 20\n      total 100000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (str \&quot;bulkinput/em-\&quot; total \&quot;.edn\&quot;)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 283, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 20\n      total 100000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 294, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 1000\n      total 100000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-100000-10000.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 183, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 10000\n      total 100000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 297, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 10000\n      total 1000000]\n  (let [chunks (partition chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 298, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 100\n      total 10000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 298, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 100\n      total 100000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 299, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 100\n      total 1000000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 300, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 1000\n      total 1000000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 301, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-1000000-1000.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 183, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-100000-1000.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 182, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          #_ (spit (:out-file w) task :append true))))))&quot;, :offset 2241, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true))))))&quot;, :offset 2238, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          ;;; todo batch spits instead of spitting individually?\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          #_(spit (:out-file w) task :append true))))))&quot;, :offset 2240, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file  (str\n                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                     smtp-ip \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files for latter appends, including now a header\n\n    (doseq [w workers]\n      (spit (:out-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    (pln :summary)\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)\n\n    #_(doseq [w workers]\n        (edn-dump (:out-file w)))))&quot;, :offset 3092, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file (str\n                    (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                    smtp-ip \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit file with a header ----------------------\n\n    (spit spit-file\n      {:run-date (.toString (java.util.Date.))\n       :smtp-ip  (:smtp-ip w)})\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [em (&lt;! spit-chan)]\n          (spit spit-file em :append true))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n    \n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n    \n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3441, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n          \n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (&gt;!! task (:spit-chan w)))))))&quot;, :offset 2170, :ns &quot;spamgen.core&quot;} {:command &quot;(.toString (java.util.Date.))&quot;, :offset 29, :ns &quot;spamgen.core&quot;} {:command &quot;(java.util.Date.)&quot;, :offset 17, :ns &quot;spamgen.core&quot;} {:command &quot;(quot (System/currentTimeMillis) 1000)&quot;, :offset 38, :ns &quot;spamgen.core&quot;} {:command &quot;(System/currentTimeMillis)&quot;, :offset 26, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file (str\n                    (:bulkmail-out-path env-hack) \n                    \&quot;/em-\&quot; (System/currentTimeMillis) \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit file with a header ----------------------\n\n    (spit spit-file\n      {:run-date (.toString (java.util.Date.))\n       :smtp-ip  (:smtp-ip w)})\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [em (&lt;! spit-chan)]\n          (spit spit-file em :append true))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3453, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file (str\n                    (:bulkmail-out-path env-hack)\n                    \&quot;/em-\&quot; (System/currentTimeMillis) \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n                        :out-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit file with a header ----------------------\n\n    (spit spit-file\n      {:run-date (.toString (java.util.Date.))\n       :smtp-ip  (:smtp-ip w)})\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [em (&lt;! spit-chan)]\n          (spit spit-file em :append true))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3619, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          (spit (:out-file w) task :append true)))\n          (&gt;!! [(:spit-file w) task] (:spit-chan w)))))&quot;, :offset 2226, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          ;; (spit (:out-file w) task :append true)))\n          (&gt;!! [(:spit-file w) task] (:spit-chan w)))))))&quot;, :offset 2231, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          ;; (spit (:out-file w) task :append true)))\n          (go (&gt;! [(:spit-file w) task] (:spit-chan w))))))))&quot;, :offset 2235, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          #_(pln :sending-to (:id w) (:spam-score task)\n              :mean (/ new-sum new-ct))\n          ;; (spit (:spit-file w) task :append true)))\n          (go (&gt;! (:spit-chan w)\n                [(:spit-file w) task])))))))&quot;, :offset 2252, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (pln :sending-to (:spit-chan w) [(:spit-file w) task])\n          ;; (spit (:spit-file w) task :append true)))\n          #_\n          (&gt;! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2225, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file (str\n                    (:bulkmail-out-path env-hack)\n                    \&quot;/em-\&quot; (System/currentTimeMillis) \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [x (&lt;! spit-chan)]\n          (when x\n            (let [[spit-file em] x]\n              (spit spit-file em :append true))))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3715, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        spit-file (str\n                    (:bulkmail-out-path env-hack)\n                    \&quot;/em-\&quot; (System/currentTimeMillis) \&quot;.edn\&quot;)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.txt\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [x (&lt;! spit-chan)]\n          (let [[spit-file em] x]\n            (spit spit-file em :append true)))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3692, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 10\n      total 50]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 294, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-50-10.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 176, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (pln :sending-to (:spit-chan w) [(:spit-file w) task])\n          ;; (spit (:spit-file w) task :append true)))\n          \n          (&gt;! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2223, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan 100)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spitter   spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [x (&lt;! spit-chan)]\n          (let [[spit-file em] x]\n            (pln :sptting spit-file em)\n            (spit spit-file em :append true)))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3597, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (pln :sending-to (:spit-chan w) [(:spit-file w) task])\n          ;; (spit (:spit-file w) task :append true)))\n\n          (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2214, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 50\n      total 1000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 296, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-100-20.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 177, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan   spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file  (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (p :spitting\n      (go-loop []\n        (when-let [x (&lt;! spit-chan)]\n          (pln :xx x)\n          (let [[spit-file em] x]\n            (pln :sptting spit-file em)\n            (spit spit-file em :append true)))))\n\n    ;; --- feed the workers ----------------------------------------\n\n    (p :feed-workers\n      (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n        (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n          (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n            (&gt;!! shared-chan em-chunk)))))\n\n    ;; --- let the workers finish ----------------------------------\n\n    (pln :waiting-on-workers)\n\n    (loop [[work-proc &amp; rest :as ps] work-procs]\n      (when work-proc\n        (when-let [out (alt!!\n                         (timeout 100) :timeout\n                         work-proc ([r] r))]\n          (recur rest))))\n\n    ;; --- dump worker stats ---------------------------------------\n\n    (when verbose\n      (doseq [w workers]\n        (pln)\n        (pln (format \&quot;worker %d:\&quot; (:id w)))\n        (pp/pprint @(:stats w))\n        (pln)))\n\n    ;; ---- dump summary stats -------------------------------------\n\n    (pp/pprint (apply merge-with +\n                 (map #(select-keys @(:stats %)\n                         [:sent-ct :rejected-score :rejected-dup-addr\n                          :rejected-overall-mean\n                          :rejected-span-mean])\n                   workers)))\n\n    (pln)\n    (println :fini)))&quot;, :offset 3617, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 20\n      total 100]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 295, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :xx x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (recur rest))))\n\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 3921, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :xx x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (recur rest))))\n\n      ;; waiting on spitter\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 3949, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :xx x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 3995, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :xx x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4026, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-200-20.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 177, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 20\n      total 200]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 295, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk)\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :xx x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4075, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :got-spit x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4098, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :got-spit x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)\n                          (recur)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 100) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4132, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan 100)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (when-let [x (&lt;! spit-chan)]\n                        (pln :got-spit x)\n                        (let [[spit-file em] x]\n                          (pln :sptting spit-file em)\n                          (spit spit-file em :append true)\n                          (recur)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 1000) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 1000) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4134, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (pln :sending-to (:spit-chan w) [(:spit-file w) task])\n          \n          #_\n          (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2182, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          #_\n          (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2173, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 5\n      total 60]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 293, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-60-5.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 175, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (if-let [x (&lt;! spit-chan)]\n                        (do\n                          (pln :got-spit x)\n                          (let [[spit-file em] x]\n                            (pln :sptting spit-file em)\n                            (spit spit-file em :append true)\n                            (recur)))\n                        (pln :spitter-out!!!!))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 1000) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 1000) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4214, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          \n          (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2171, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (if-let [x (&lt;! spit-chan)]\n                        (let [[spit-file em] x]\n                          (xpln :sptting spit-file em)\n                          (spit spit-file em :append true)\n                          (recur))\n                        (pln :spitter-out!!!!))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 1000) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 1000) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4134, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                (pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (if-let [x (&lt;! spit-chan)]\n                        (let [[spit-file em] x]\n                          (xpln :sptting spit-file em)\n                          (spit spit-file em :append true)\n                          (recur))\n                        (pln :spitter-out!!!!))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (pln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 1000) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4133, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                ;;(pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitter (p :spitting\n                    (go-loop []\n                      (if-let [x (&lt;! spit-chan)]\n                        (let [[spit-file em] x]\n                          (xpln :sptting spit-file em)\n                          (spit spit-file em :append true)\n                          (recur))\n                        (pln :spitter-out!!!!))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (xpln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 1000) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4136, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-1000-50.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 178, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n          \n          (spit (:spit-file w) task :append true)\n\n\n          #_ (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2225, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          ;(spit (:spit-file w) task :append true)\n\n\n          #_ (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2216, :ns &quot;spamgen.core&quot;} {:command &quot;(let [chunk 100\n      total 300000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 299, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 100\n      total 200000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 299, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          ;;(spit (:spit-file w) task :append true)\n\n\n          (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2214, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-100000-100.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 181, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-10000-100.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 180, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-40000-100.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 180, :ns &quot;spamgen.core-test&quot;} {:command &quot;(let [chunk 100\n      total 40000]\n  (let [chunks (partition-all chunk\n                 (email-records-test-gen total))]\n    (dorun\n      (map (fn [n c]\n             (spit (format \&quot;bulkinput/em-%d-%d.edn\&quot; total chunk)\n               (into [] c) :append (pos? n)))\n        (range)\n        chunks))))&quot;, :offset 298, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                ;;(pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitters\n          (for [_ (range 5)]\n            (p :spitting\n                    (go-loop []\n                      (if-let [x (&lt;! spit-chan)]\n                        (let [[spit-file em] x]\n                          (xpln :sptting spit-file em)\n                          (spit spit-file em :append true)\n                          (recur))\n                        (pln :spitter-out!!!!)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (xpln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitter)\n      (when-let [out (alt!!\n                       (timeout 1000) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4179, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                ;;(pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitters\n          (for [_ (range 5)]\n            (p :spitting\n                    (go-loop []\n                      (if-let [x (&lt;! spit-chan)]\n                        (let [[spit-file em] x]\n                          (xpln :sptting spit-file em)\n                          (spit spit-file em :append true)\n                          (recur))\n                        (pln :spitter-out!!!!)))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (xpln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitterc)\n      (doseq [spitter spitters]\n      (when-let [out (alt!!\n                       (timeout 1000) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out)))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4213, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                ;;(pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitters\n          (doall (for [_ (range 5)]\n            (p :spitting\n                    (go-loop []\n                      (if-let [x (&lt;! spit-chan)]\n                        (let [[spit-file em] x]\n                          (xpln :sptting spit-file em)\n                          (spit spit-file em :append true)\n                          (recur))\n                        (pln :spitter-out!!!!))))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (p :feed-workers\n        (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n          (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n            (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n              (xpln :chunk-top)\n              (&gt;!! shared-chan em-chunk)))))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitterc)\n      (doseq [spitter spitters]\n      (when-let [out (alt!!\n                       (timeout 1000) :timeout\n                       spitter ([r] r))]\n        (print :spitwait out)))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4221, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (spit (:spit-file w) task :append true)\n\n\n          #_ (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2215, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (length @(:out-buff w)) 100)\n              (spit (:spit-file w) (:out-buff w) :append true)\n              (reset! (:out-buff w) nil))\n          \n          (swap! (:out-buff w) conj task)\n\n          #_ (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2371, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 100)\n              (spit (:spit-file w) (:out-buff w) :append true)\n              (reset! (:out-buff w) nil))\n          \n          (swap! (:out-buff w) conj task)\n\n          #_ (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2370, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-1000000-100.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 182, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 1000)\n              (spit (:spit-file w) @(:out-buff w) :append true)\n              (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_ (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2362, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 50)\n              (spit (:spit-file w) @(:out-buff w) :append true)\n              (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_ (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2360, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 100)\n              (spit (:spit-file w) @(:out-buff w) :append true)\n              (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_ (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2361, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 200)\n              (spit (:spit-file w) @(:out-buff w) :append true)\n              (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_ (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2361, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 500)\n              (spit (:spit-file w) @(:out-buff w) :append true)\n              (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_ (&gt;!! (:spit-chan w)\n            [(:spit-file w) task]))))))&quot;, :offset 2361, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-300000-100.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 181, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defnp span-mean-ok\n  \&quot;[w (writer) new-score (score of email being considered)]\n  Decide if this new score, if included, will violate running mean score\n  invariants specified in config.edn\&quot;\n\n  [w new-score]\n\n  (let [stats @(:stats w)\n        last-n-mean (:last-n-mean stats)\n        new-ct (min\n                 (:last-n-span env-hack)\n                 (inc (:sent-ct stats)))\n        new-mean (+ last-n-mean\n                   (/ (- new-score last-n-mean) new-ct))]\n    (if (&lt;= new-mean (:last-n-mean-max env-hack))\n      (do\n        (swap! (:stats w) assoc :last-n-mean new-mean)\n        #_(pln :okspan new-ct new-mean new-score (:last-n-mean-max env-hack))\n        true)\n      (do\n        #_(pln :failspan new-ct new-mean (:last-n-mean-max env-hack))\n        false))))&quot;, :offset 772, :ns &quot;spamgen.core&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :out-buff  (atom nil)\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                ;;(pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitters\n          nil #_(doall (for [_ (range 5)]\n                         (p :spitting\n                           (go-loop []\n                             (if-let [x (&lt;! spit-chan)]\n                               (let [[spit-file em] x]\n                                 (xpln :sptting spit-file em)\n                                 (spit spit-file em :append true)\n                                 (recur))\n                               (pln :spitter-out!!!!))))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (let [wait (atom 0)]\n        (p :feed-workers\n          (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n            (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n              (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n                (xpln :chunk-top)\n                (let [start (System/currentTimeMillis)]\n                  (&gt;!! shared-chan em-chunk)\n                  (swap! wait + (- (System/currentTimeMillis) start)))))))\n        (pln :feeder-waited @wait :miilis))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            (pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitterc)\n      (doseq [spitter spitters]\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         spitter ([r] r))]\n          (print :spitwait out)))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4555, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      ;(swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do ;(swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do ;(swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when true #_ (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      ;(swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          #_ (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 500)\n            (spit (:spit-file w) @(:out-buff w) :append true)\n            (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_(&gt;!! (:spit-chan w)\n              [(:spit-file w) task]))))))&quot;, :offset 2373, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      ;(swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do ;(swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when true #_ (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      ;(swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          #_ (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 500)\n            (spit (:spit-file w) @(:out-buff w) :append true)\n            (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_(&gt;!! (:spit-chan w)\n              [(:spit-file w) task]))))))&quot;, :offset 2372, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      ;(swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do ;(swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when true #_ (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      ;(swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 500)\n            (spit (:spit-file w) @(:out-buff w) :append true)\n            (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_(&gt;!! (:spit-chan w)\n              [(:spit-file w) task]))))))&quot;, :offset 2369, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      ;(swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do ;(swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      ;(swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 500)\n            (spit (:spit-file w) @(:out-buff w) :append true)\n            (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_(&gt;!! (:spit-chan w)\n              [(:spit-file w) task]))))))&quot;, :offset 2361, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      ;(swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      ;(swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 500)\n            (spit (:spit-file w) @(:out-buff w) :append true)\n            (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_(&gt;!! (:spit-chan w)\n              [(:spit-file w) task]))))))&quot;, :offset 2360, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (p :span-mean (span-mean-ok w (:spam-score task))))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 500)\n            (spit (:spit-file w) @(:out-buff w) :append true)\n            (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_(&gt;!! (:spit-chan w)\n              [(:spit-file w) task]))))))&quot;, :offset 2358, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (span-mean-ok w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (when (dosync\n                ;; todo make sure addr key matches generator when testing\n                ;; or work out how to normalize keys in spec\n                (let [addr (:email-address task)]\n                  (if (get @(:addrs-hit w) addr)\n                    (do\n                      (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n                      false)\n                    (do\n                      (alter (:addrs-hit w) conj addr)\n                      true))))\n          (swap! (:stats w) merge {:sent-ct        new-ct\n                                   :spam-score-sum new-sum})\n\n          (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n          (when (&gt;= (count @(:out-buff w)) 500)\n            (spit (:spit-file w) @(:out-buff w) :append true)\n            (reset! (:out-buff w) nil))\n\n          (swap! (:out-buff w) conj task)\n\n          #_(&gt;!! (:spit-chan w)\n              [(:spit-file w) task]))))))&quot;, :offset 2343, :ns &quot;spamgen.core&quot;} {:command &quot;(deftest slurptest\n  (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-200000-100.edn\&quot;\n        false))&quot;, :offset 102, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest-unprof\n  (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-200000-100.edn\&quot;\n        false))&quot;, :offset 109, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest\n  (profile\n    {:dynamic? true}\n    (p :devtest-mp\n      (email-file-to-sendfiles-mp\n        \&quot;bulkinput/em-200000-100.edn\&quot;\n        false)))\n  (pln :devtest-fini))&quot;, :offset 181, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest-unprof\n  (let [wait (atom 0)]\n    (email-file-to-sendfiles-mp\n      \&quot;bulkinput/em-200000-100.edn\&quot;\n      false)\n    (pln :slurptest-took @wait :miilis)))&quot;, :offset 171, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest-unprof\n  (let [wait (atom (System/currentTimeMillis))]\n    (email-file-to-sendfiles-mp\n      \&quot;bulkinput/em-200000-100.edn\&quot;\n      false)\n    (pln :slurptest-took (- (System/currentTimeMillis) \n                           (@wait :miilis)))))&quot;, :offset 257, :ns &quot;spamgen.core-test&quot;} {:command &quot;(deftest slurptest-unprof\n  (let [wait (atom (System/currentTimeMillis))]\n    (email-file-to-sendfiles-mp\n      \&quot;bulkinput/em-200000-100.edn\&quot;\n      false)\n    (pln :slurptest-took (- (System/currentTimeMillis) @wait))))&quot;, :offset 219, :ns &quot;spamgen.core-test&quot;} {:command &quot;(defn email-file-to-sendfiles-mp\n  \&quot;[em-file (coll)]\n\n  Produce one or more output files targeted\n  for different SMTP servers constraining the sequence of emails\n  in each to honor spam score constraints specified in config.edn\n  and never to include two emails to the same address across all\n  batches.\&quot;\n  [em-file verbose]\n\n  (let [em-addrs-hit (ref #{})\n        shared-chan (chan)\n        spit-chan (chan)\n        workers (map (fn [id smtp-ip]\n                       {:id        id\n                        :smtp-ip   smtp-ip\n                        :ch        shared-chan\n                        :spit-chan spit-chan\n                        :out-buff  (atom nil)\n                        :addrs-hit em-addrs-hit\n                        :spit-file (str\n                                     (:bulkmail-out-path env-hack) \&quot;/em-\&quot;\n                                     smtp-ip \&quot;.edn\&quot;)\n\n                        :stats     (atom {:sent-ct               0\n                                          :last-n-mean           0\n                                          :spam-score-sum        0\n                                          :rejected-score        0\n                                          :rejected-dup-addr     0\n                                          :rejected-overall-mean 0\n                                          :rejected-span-mean    0})})\n                  (range)\n                  (take (min (count (:smtp env-hack))\n                          (:worker-ct env-hack))\n                    (:smtp env-hack)))\n\n        work-procs (doall\n                     (map (fn [w]\n                            (go-loop []\n                              (when-let [em-chunk (&lt;! (:ch w))]\n                                ;;(pln :got-chunk (count em-chunk))\n                                (doseq [em em-chunk]\n                                  (emw-email-consider w em))\n                                (recur))))\n                       workers))]\n\n    ;; --- initialize spit files with a header ----------------------\n\n    (doseq [w workers]\n      (spit (:spit-file w)\n        {:run-date (.toString (java.util.Date.))\n         :smtp-ip  (:smtp-ip w)}))\n\n    ;; --- start the spitter ---------------------------------------\n\n    (let [spitters\n          nil #_(doall (for [_ (range 5)]\n                         (p :spitting\n                           (go-loop []\n                             (if-let [x (&lt;! spit-chan)]\n                               (let [[spit-file em] x]\n                                 (xpln :sptting spit-file em)\n                                 (spit spit-file em :append true)\n                                 (recur))\n                               (pln :spitter-out!!!!))))))]\n\n      ;; --- feed the workers ----------------------------------------\n\n      (let [wait (atom 0)]\n        (p :feed-workers\n          (with-open [in (java.io.PushbackReader. (clojure.java.io/reader em-file))]\n            (let [edn-seq (repeatedly (partial edn/read {:eof :fini} in))]\n              (doseq [em-chunk (take-while (partial not= :fini) edn-seq)]\n                (xpln :chunk-top)\n                (let [start (System/currentTimeMillis)]\n                  (&gt;!! shared-chan em-chunk)\n                  (swap! wait + (- (System/currentTimeMillis) start)))))))\n        (pln :feeder-waited @wait :miilis))\n\n      ;; --- let the workers finish ----------------------------------\n\n      (pln :waiting-on-workers)\n\n      (loop [[work-proc &amp; rest :as ps] work-procs]\n        (when work-proc\n          (when-let [out (alt!!\n                           (timeout 100) :timeout\n                           work-proc ([r] r))]\n            ;;(pln :bam-worker-out work-proc)\n            (recur rest))))\n\n      (pln :waitingonspitterc)\n      (doseq [spitter spitters]\n        (when-let [out (alt!!\n                         (timeout 1000) :timeout\n                         spitter ([r] r))]\n          (print :spitwait out)))\n\n      ;; --- dump worker stats ---------------------------------------\n\n      (when verbose\n        (doseq [w workers]\n          (pln)\n          (pln (format \&quot;worker %d:\&quot; (:id w)))\n          (pp/pprint @(:stats w))\n          (pln)))\n\n      ;; ---- dump summary stats -------------------------------------\n\n      (pp/pprint (apply merge-with +\n                   (map #(select-keys @(:stats %)\n                           [:sent-ct :rejected-score :rejected-dup-addr\n                            :rejected-overall-mean\n                            :rejected-span-mean])\n                     workers)))\n\n      (pln)\n      (println :fini))))&quot;, :offset 4557, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (span-mean-ok w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (if (get @(:addrs-hit w) (:email-address task))\n          (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n          (do\n            (alter (:addrs-hit w) conj (:email-address task))\n            (swap! (:stats w) merge {:sent-ct        new-ct\n                                     :spam-score-sum new-sum})\n\n            (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n            (when (&gt;= (count @(:out-buff w)) 500)\n              (spit (:spit-file w) @(:out-buff w) :append true)\n              (reset! (:out-buff w) nil))\n\n            (swap! (:out-buff w) conj task)\n\n          #_(&gt;!! (:spit-chan w)\n              [(:spit-file w) task])))))))&quot;, :offset 2059, :ns &quot;spamgen.core&quot;} {:command &quot;(defnp emw-email-consider\n  \&quot;[w (writer) task (email info)]\n  Decide whether this writer should include this email in\n  the batch, given its spam score and how it will affect the\n  overall spam score of this writer's output and the running\n  mean spam score of the most recent emails.\n\n  Simply write to the writer's batch or ignore. Output is meaningless.\&quot;\n\n  [w task]\n\n  (xpln :consider (:spam-score task) (:email-address task))\n\n  (cond\n    (&gt; (:spam-score task) (:individual-max env-hack))\n    (do\n      (swap! (:stats w) update-in [:rejected-score] inc)\n      (xpln :email-indy-bad :w (:id w) :score (:spam-score task)))\n\n    :default\n    (let [stats @(:stats w)\n          new-sum (+ (:spam-score task) (:spam-score-sum stats))\n          new-ct (inc (:sent-ct stats))]\n      (cond\n        (&gt; (/ new-sum new-ct)\n          (:overall-mean-max env-hack))\n        (do (swap! (:stats w) update-in [:rejected-overall-mean] inc)\n            (xpln :overall-email-mean-bad :score (:spam-score task)\n              :new-mean (/ new-sum new-ct)\n              :limit (:overall-mean-max env-hack)))\n\n        (not (span-mean-ok w (:spam-score task)))\n        ;; todo save to \&quot;try later\&quot; array to be possibly\n        ;; incorporated later when running mean might drop\n        (do (swap! (:stats w) update-in [:rejected-span-mean] inc)\n            (pln :span-mean-bad (:spam-score task)))\n\n        :default\n        (if (get @(:addrs-hit w) (:email-address task))\n          (swap! (:stats w) update-in [:rejected-dup-addr] inc)\n          (do\n            (dosync (alter (:addrs-hit w) conj (:email-address task)))\n            (swap! (:stats w) merge {:sent-ct        new-ct\n                                     :spam-score-sum new-sum})\n\n            (xpln :sending-to (:spit-chan w) [(:spit-file w) task])\n\n            (when (&gt;= (count @(:out-buff w)) 500)\n              (spit (:spit-file w) @(:out-buff w) :append true)\n              (reset! (:out-buff w) nil))\n\n            (swap! (:out-buff w) conj task)\n\n          #_(&gt;!! (:spit-chan w)\n              [(:spit-file w) task])))))))&quot;, :offset 2068, :ns &quot;spamgen.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.main">
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
    <configuration name="main" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="1" />
      <module name="spamgen" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7cb0b57d-e445-4e92-bfe3-6ba51a3c0109" name="Default" comment="" />
      <created>1521628166875</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1521628166875</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="93" y="68" width="1544" height="886" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.4423575" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.13912475" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
    </layout>
    <layout-to-restore>
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.3435663" sideWeight="0.5" order="9" side_tool="true" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="3" side_tool="false" content_ui="combo" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" x="193" y="167" width="1294" height="686" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.13912475" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
    </layout-to-restore>
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/test/spamgen/core_test.clj</url>
          <line>9</line>
          <properties />
          <option name="timeStamp" value="1" />
        </line-breakpoint>
      </breakpoints>
      <option name="time" value="11" />
    </breakpoint-manager>
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="153">
          <caret line="9" column="0" lean-forward="false" selection-start-line="9" selection-start-column="0" selection-end-line="9" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="17">
          <caret line="1" column="0" lean-forward="true" selection-start-line="1" selection-start-column="0" selection-end-line="1" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="18" lean-forward="true" selection-start-line="7" selection-start-column="18" selection-end-line="7" selection-end-column="18" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="249">
          <caret line="3207" column="10" lean-forward="false" selection-start-line="3207" selection-start-column="10" selection-end-line="3207" selection-end-column="10" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="357">
          <caret line="21" column="56" lean-forward="false" selection-start-line="21" selection-start-column="56" selection-end-line="21" selection-end-column="56" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/config/dev/config.edn">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="119">
          <caret line="7" column="13" lean-forward="false" selection-start-line="7" selection-start-column="1" selection-end-line="7" selection-end-column="13" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/genlist.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="276">
          <caret line="40" column="17" lean-forward="true" selection-start-line="40" selection-start-column="17" selection-end-line="40" selection-end-column="17" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/spamgen/core_test.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="409">
          <caret line="129" column="33" lean-forward="true" selection-start-line="129" selection-start-column="33" selection-end-line="129" selection-end-column="33" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/spamgen/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="381">
          <caret line="251" column="41" lean-forward="true" selection-start-line="251" selection-start-column="41" selection-end-line="251" selection-end-column="41" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>